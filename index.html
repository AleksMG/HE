<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –û–º–æ—Ñ–æ–Ω–∏–∫–æ-–ì–æ–º–æ–º–æ—Ä—Ñ–Ω–∞—è –ö—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º–∞</title>
    <style>
        :root {
            --primary: #0a0a0a;
            --secondary: #1a1a1a;
            --accent: #2d2d2d;
            --success: #00cc88;
            --warning: #ffaa00;
            --danger: #ff4444;
            --background: #000000;
            --surface: #111111;
            --text: #ffffff;
            --border: #333333;
            --code: #00ff88;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'IBM Plex Mono', 'JetBrains Mono', monospace;
        }

        body {
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: var(--surface);
            color: var(--text);
            padding: 2rem;
            text-align: center;
            border: 1px solid var(--border);
            margin-bottom: 2rem;
            border-radius: 8px;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
            color: var(--success);
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--warning);
        }

        .grid-system {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
        }

        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 20px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border);
        }

        .panel-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--success);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            background: var(--accent);
            color: var(--text);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            background: var(--success);
            color: var(--background);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text);
            font-size: 0.9rem;
        }

        input, select {
            width: 100%;
            padding: 0.75rem;
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 0.9rem;
        }

        .result-area {
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .test-result {
            padding: 0.75rem;
            margin: 0.5rem 0;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .test-pass {
            background: rgba(0, 204, 136, 0.1);
            border-left: 4px solid var(--success);
            color: var(--success);
        }

        .test-fail {
            background: rgba(255, 68, 68, 0.1);
            border-left: 4px solid var(--danger);
            color: var(--danger);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-active { background: var(--success); }
        .status-warning { background: var(--warning); }
        .status-danger { background: var(--danger); }

        .crypto-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 1px;
            margin: 1rem 0;
            font-size: 0.7rem;
        }

        .crypto-cell {
            padding: 0.5rem;
            border: 1px solid var(--border);
            text-align: center;
            background: var(--background);
            cursor: pointer;
        }

        .operation-flow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 1rem 0;
            padding: 1rem;
            background: var(--background);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .operation-step {
            text-align: center;
            padding: 0.5rem;
            flex: 1;
            font-size: 0.9rem;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .metric-box {
            padding: 1rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--background);
            text-align: center;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--success);
            margin: 0.5rem 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîê –ü–†–û–§–ï–°–°–ò–û–ù–ê–õ–¨–ù–ê–Ø –ö–†–ò–ü–¢–û–°–ò–°–¢–ï–ú–ê</h1>
            <p class="subtitle">–ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–∏–º–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞–º–∏</p>
        </header>

        <div class="grid-system">
            <!-- –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">‚öôÔ∏è –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø</h3>
                    </div>
                    
                    <div class="form-group">
                        <label>–†–∞–∑–º–µ—Ä –ø–æ–ª—è (p):</label>
                        <input type="number" id="field-size" value="251" min="127" max="65535">
                    </div>

                    <div class="form-group">
                        <label>–ö–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
                        <input type="text" id="crypto-key" value="strong-secret-key-256-bit">
                    </div>

                    <button class="btn" onclick="initializeSystem()">
                        üöÄ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ò–†–û–í–ê–¢–¨ –°–ò–°–¢–ï–ú–£
                    </button>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üß™ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï</h3>
                    </div>
                    
                    <button class="btn" onclick="runAllTests()">
                        ‚úÖ –ó–ê–ü–£–°–¢–ò–¢–¨ –í–°–ï –¢–ï–°–¢–´
                    </button>

                    <button class="btn" onclick="testReversibility()">
                        üîÑ –¢–ï–°–¢ –û–ë–†–ê–¢–ò–ú–û–°–¢–ò
                    </button>

                    <button class="btn" onclick="testHomomorphicProperties()">
                        üßÆ –¢–ï–°–¢ –ì–û–ú–û–ú–û–†–§–ò–ò
                    </button>

                    <button class="btn" onclick="testCryptographicSecurity()">
                        üîí –¢–ï–°–¢ –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò
                    </button>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üìä –°–¢–ê–¢–£–°</h3>
                    </div>
                    
                    <div class="result-area">
                        <div><span class="status-indicator" id="status-sbox-indicator"></span>S-Box: <span id="status-sbox">–ù–ï–ò–ù–ò–¶</span></div>
                        <div><span class="status-indicator" id="status-crypto-indicator"></span>–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è: <span id="status-crypto">–û–¢–ö–õ</span></div>
                        <div><span class="status-indicator" id="status-homo-indicator"></span>–ì–æ–º–æ–º–æ—Ä—Ñ–∏—è: <span id="status-homo">–û–¢–ö–õ</span></div>
                        <div><span class="status-indicator" id="status-test-indicator"></span>–¢–µ—Å—Ç—ã: <span id="status-test">–ù–ï –ó–ê–ü–£–©–ï–ù–´</span></div>
                    </div>
                </div>
            </div>

            <!-- –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å - –†–∞–±–æ—Ç–∞ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üî¢ –û–ü–ï–†–ê–¶–ò–ò</h3>
                    </div>
                    
                    <div class="form-group">
                        <label>–ß–∏—Å–ª–æ A:</label>
                        <input type="number" id="input-a" value="7" min="0" max="250">
                    </div>

                    <div class="form-group">
                        <label>–ß–∏—Å–ª–æ B:</label>
                        <input type="number" id="input-b" value="5" min="0" max="250">
                    </div>

                    <div class="operation-flow">
                        <div class="operation-step">A ‚Üí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ ‚Üí</div>
                        <div class="operation-step" style="font-size: 1.5rem;">+</div>
                        <div class="operation-step">B ‚Üí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ ‚Üí</div>
                        <div class="operation-step" style="font-size: 1.5rem;">=</div>
                        <div class="operation-step">‚Üê –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ ‚Üê</div>
                    </div>

                    <button class="btn" onclick="performHomomorphicAddition()">
                        ‚ûï –í–´–ü–û–õ–ù–ò–¢–¨ –°–õ–û–ñ–ï–ù–ò–ï
                    </button>

                    <div class="result-area" id="operation-result">
                        –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å...
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üìà –†–ï–ó–£–õ–¨–¢–ê–¢–´ –¢–ï–°–¢–û–í</h3>
                    </div>
                    
                    <div class="result-area" id="test-results">
                        <div class="test-result test-fail">‚ùå –û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å: –ù–ï –ü–†–û–í–ï–†–ï–ù–û</div>
                        <div class="test-result test-fail">‚ùå –ì–æ–º–æ–º–æ—Ä—Ñ–∏—è: –ù–ï –ü–†–û–í–ï–†–ï–ù–û</div>
                        <div class="test-result test-fail">‚ùå –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å: –ù–ï –ü–†–û–í–ï–†–ï–ù–û</div>
                        <div class="test-result test-fail">‚ùå –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: –ù–ï –ü–†–û–í–ï–†–ï–ù–û</div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üìä –ú–ï–¢–†–ò–ö–ò –°–ò–°–¢–ï–ú–´</h3>
                    </div>
                    
                    <div class="metric-grid">
                        <div class="metric-box">
                            <div>–≠–Ω—Ç—Ä–æ–ø–∏—è</div>
                            <div class="metric-value" id="metric-entropy">0.00</div>
                            <div>–±–∏—Ç/–±–∞–π—Ç</div>
                        </div>
                        <div class="metric-box">
                            <div>–õ–∞–≤–∏–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç</div>
                            <div class="metric-value" id="metric-avalanche">0%</div>
                            <div>–∏–∑–º–µ–Ω–µ–Ω–∏–µ –±–∏—Ç</div>
                        </div>
                        <div class="metric-box">
                            <div>–°–∫–æ—Ä–æ—Å—Ç—å</div>
                            <div class="metric-value" id="metric-speed">0</div>
                            <div>–æ–ø/—Å–µ–∫</div>
                        </div>
                        <div class="metric-box">
                            <div>–û—à–∏–±–∫–∏</div>
                            <div class="metric-value" id="metric-errors">0</div>
                            <div>–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =============================================================================
        // –ü–†–û–§–ï–°–°–ò–û–ù–ê–õ–¨–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø –ö–†–ò–ü–¢–û–°–ò–°–¢–ï–ú–´
        // =============================================================================

        class ProfessionalCryptoSystem {
            constructor() {
                this.initialized = false;
                this.fieldSize = 251n;
                this.sBox = new Map();
                this.inverseSBox = new Map();
                this.keyMaterial = null;
                this.testResults = {
                    reversibility: { passed: false, message: "–ù–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–ª–æ—Å—å" },
                    homomorphic: { passed: false, message: "–ù–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–ª–æ—Å—å" },
                    security: { passed: false, message: "–ù–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–ª–æ—Å—å" },
                    performance: { passed: false, message: "–ù–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–ª–æ—Å—å" }
                };
                this.metrics = {
                    entropy: 0,
                    avalanche: 0,
                    speed: 0,
                    errors: 0
                };
            }

            // =============================================================================
            // –û–°–ù–û–í–ù–´–ï –ú–ï–¢–û–î–´
            // =============================================================================

            async initializeSystem(fieldSize, key) {
                try {
                    this.fieldSize = BigInt(fieldSize);
                    this.keyMaterial = await this.deriveKey(key);
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ–≥–æ S-Box
                    await this.generateSBox();
                    
                    // –ó–∞–ø—É—Å–∫ –±–∞–∑–æ–≤—ã—Ö —Ç–µ—Å—Ç–æ–≤
                    await this.runInitialTests();
                    
                    this.initialized = true;
                    return true;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
                    this.metrics.errors++;
                    return false;
                }
            }

            async deriveKey(key) {
                const encoder = new TextEncoder();
                const keyBuffer = encoder.encode(key);
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º PBKDF2 –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–∞
                const salt = new Uint8Array(16);
                crypto.getRandomValues(salt);
                
                const importedKey = await crypto.subtle.importKey(
                    'raw', keyBuffer, { name: 'PBKDF2' }, false, ['deriveBits']
                );
                
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    importedKey,
                    256
                );
                
                return new Uint8Array(derivedBits);
            }

            async generateSBox() {
                this.sBox.clear();
                this.inverseSBox.clear();
                
                const fieldSizeNum = Number(this.fieldSize);
                
                // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—É—é –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫—É
                const basePermutation = Array.from({length: fieldSizeNum}, (_, i) => BigInt(i));
                
                // –ö—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ Fisher-Yates
                for (let i = fieldSizeNum - 1; i > 0; i--) {
                    const j = await this.getSecureRandom(i + 1);
                    [basePermutation[i], basePermutation[j]] = [basePermutation[j], basePermutation[i]];
                }
                
                // –°—Ç—Ä–æ–∏–º S-Box —Å –æ–º–æ—Ñ–æ–Ω–∞–º–∏
                for (let i = 0; i < fieldSizeNum; i++) {
                    const inputValue = BigInt(i);
                    const omophones = [];
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è 4 –æ–º–æ—Ñ–æ–Ω–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
                    for (let j = 0; j < 4; j++) {
                        const seed = await this.cryptoHash(
                            this.keyMaterial + inputValue.toString() + j.toString()
                        );
                        const omophone = this.generateOmophone(inputValue, seed, j);
                        omophones.push(omophone);
                        
                        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                        if (this.inverseSBox.has(omophone)) {
                            throw new Error("–ö–æ–ª–ª–∏–∑–∏—è –≤ S-Box!");
                        }
                        this.inverseSBox.set(omophone, inputValue);
                    }
                    
                    this.sBox.set(inputValue, omophones);
                }
            }

            async generateOmophone(value, seed, index) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º seed –≤ BigInt
                let seedBigInt = 0n;
                for (const byte of seed) {
                    seedBigInt = (seedBigInt << 8n) + BigInt(byte);
                }
                
                // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–º–æ—Ñ–æ–Ω–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º seed
                return (value + seedBigInt + BigInt(index)) % this.fieldSize;
            }

            async cryptoHash(data) {
                const encoder = new TextEncoder();
                const dataBuffer = encoder.encode(data);
                const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
                return new Uint8Array(hashBuffer);
            }

            async getSecureRandom(max) {
                const randomBuffer = new Uint32Array(1);
                crypto.getRandomValues(randomBuffer);
                return randomBuffer[0] % max;
            }

            // =============================================================================
            // –û–ü–ï–†–ê–¶–ò–ò –®–ò–§–†–û–í–ê–ù–ò–Ø/–î–ï–®–ò–§–†–û–í–ê–ù–ò–Ø
            // =============================================================================

            async encrypt(value) {
                if (!this.initialized) throw new Error("–°–∏—Å—Ç–µ–º–∞ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞");
                
                const valueBigInt = BigInt(value);
                if (valueBigInt >= this.fieldSize) {
                    throw new Error("–ó–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –ø–æ–ª—è");
                }
                
                const omophones = this.sBox.get(valueBigInt);
                if (!omophones) {
                    throw new Error("–ó–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ S-Box");
                }
                
                // –°–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä –æ–º–æ—Ñ–æ–Ω–∞
                const randomIndex = await this.getSecureRandom(omophones.length);
                return omophones[randomIndex];
            }

            async decrypt(encryptedValue) {
                if (!this.initialized) throw new Error("–°–∏—Å—Ç–µ–º–∞ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞");
                
                const result = this.inverseSBox.get(encryptedValue);
                if (result === undefined) {
                    throw new Error("–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ");
                }
                
                return result;
            }

            // =============================================================================
            // –ì–û–ú–û–ú–û–†–§–ù–´–ï –û–ü–ï–†–ê–¶–ò–ò
            // =============================================================================

            async homomorphicAdd(encryptedA, encryptedB) {
                // –ü—Ä–æ—Å—Ç–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ –ø–æ –º–æ–¥—É–ª—é (–¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏)
                // –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ —ç—Ç–æ –±—ã–ª–∞ –±—ã –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è
                return (encryptedA + encryptedB) % this.fieldSize;
            }

            async homomorphicMultiply(encryptedA, encryptedB) {
                // –£–º–Ω–æ–∂–µ–Ω–∏–µ –ø–æ –º–æ–¥—É–ª—é
                return (encryptedA * encryptedB) % this.fieldSize;
            }

            // =============================================================================
            // –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ò –í–ï–†–ò–§–ò–ö–ê–¶–ò–Ø
            // =============================================================================

            async runInitialTests() {
                this.testResults.reversibility = await this.testReversibility();
                this.testResults.homomorphic = await this.testHomomorphicProperties();
                this.testResults.security = await this.testSecurity();
                this.testResults.performance = await this.testPerformance();
                
                await this.calculateMetrics();
            }

            async testReversibility() {
                const testCases = 100;
                let passed = 0;
                
                for (let i = 0; i < testCases; i++) {
                    try {
                        const testValue = BigInt(Math.floor(Math.random() * Number(this.fieldSize)));
                        const encrypted = await this.encrypt(testValue);
                        const decrypted = await this.decrypt(encrypted);
                        
                        if (decrypted === testValue) {
                            passed++;
                        }
                    } catch (error) {
                        console.error("–û—à–∏–±–∫–∞ –≤ —Ç–µ—Å—Ç–µ –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏:", error);
                    }
                }
                
                return {
                    passed: passed === testCases,
                    message: `${passed}/${testCases} —Ç–µ—Å—Ç–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ`
                };
            }

            async testHomomorphicProperties() {
                const testCases = 50;
                let passed = 0;
                
                for (let i = 0; i < testCases; i++) {
                    try {
                        const a = BigInt(Math.floor(Math.random() * Number(this.fieldSize) / 2));
                        const b = BigInt(Math.floor(Math.random() * Number(this.fieldSize) / 2));
                        
                        // –®–∏—Ñ—Ä—É–µ–º
                        const encA = await this.encrypt(a);
                        const encB = await this.encrypt(b);
                        
                        // –ì–æ–º–æ–º–æ—Ä—Ñ–Ω–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ
                        const encSum = await this.homomorphicAdd(encA, encB);
                        
                        // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º
                        const decryptedSum = await this.decrypt(encSum);
                        const expectedSum = (a + b) % this.fieldSize;
                        
                        if (decryptedSum === expectedSum) {
                            passed++;
                        }
                    } catch (error) {
                        console.error("–û—à–∏–±–∫–∞ –≤ —Ç–µ—Å—Ç–µ –≥–æ–º–æ–º–æ—Ä—Ñ–∏–∏:", error);
                    }
                }
                
                return {
                    passed: passed === testCases,
                    message: `${passed}/${testCases} —Ç–µ—Å—Ç–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ`
                };
            }

            async testSecurity() {
                // –¢–µ—Å—Ç –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
                const avalancheResult = await this.testAvalancheEffect();
                
                // –¢–µ—Å—Ç —ç–Ω—Ç—Ä–æ–ø–∏–∏
                const entropyResult = await this.testEntropy();
                
                return {
                    passed: avalancheResult && entropyResult,
                    message: `–õ–∞–≤–∏–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç: ${avalancheResult ? '‚úì' : '‚úó'}, –≠–Ω—Ç—Ä–æ–ø–∏—è: ${entropyResult ? '‚úì' : '‚úó'}`
                };
            }

            async testAvalancheEffect() {
                const testCases = 100;
                let totalChange = 0;
                
                for (let i = 0; i < testCases; i++) {
                    const input1 = BigInt(Math.floor(Math.random() * Number(this.fieldSize)));
                    const input2 = input1 + 1n; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
                    
                    const omo1 = await this.encrypt(input1);
                    const omo2 = await this.encrypt(input2);
                    
                    // –ü–æ–¥—Å—á–µ—Ç –æ—Ç–ª–∏—á–∞—é—â–∏—Ö—Å—è –±–∏—Ç–æ–≤
                    const diff = omo1 ^ omo2;
                    let changedBits = 0;
                    for (let j = 0; j < 64; j++) {
                        if (diff & (1n << BigInt(j))) {
                            changedBits++;
                        }
                    }
                    
                    totalChange += (changedBits / 64) * 100;
                }
                
                const avgChange = totalChange / testCases;
                this.metrics.avalanche = avgChange;
                return avgChange > 45; // –î–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ–∫–æ–ª–æ 50%
            }

            async testEntropy() {
                const samples = 1000;
                const frequency = new Map();
                
                for (let i = 0; i < samples; i++) {
                    const value = BigInt(Math.floor(Math.random() * Number(this.fieldSize)));
                    const encrypted = await this.encrypt(value);
                    
                    const key = encrypted.toString();
                    frequency.set(key, (frequency.get(key) || 0) + 1);
                }
                
                let entropy = 0;
                const total = samples;
                
                for (const count of frequency.values()) {
                    const probability = count / total;
                    entropy -= probability * Math.log2(probability);
                }
                
                this.metrics.entropy = entropy;
                return entropy > 7.5; // –í—ã—Å–æ–∫–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è
            }

            async testPerformance() {
                const startTime = performance.now();
                const operations = 1000;
                
                for (let i = 0; i < operations; i++) {
                    const value = BigInt(Math.floor(Math.random() * Number(this.fieldSize)));
                    await this.encrypt(value);
                }
                
                const endTime = performance.now();
                const opsPerSecond = operations / ((endTime - startTime) / 1000);
                
                this.metrics.speed = Math.round(opsPerSecond);
                return opsPerSecond > 100;
            }

            async calculateMetrics() {
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–∞—Å—á–µ—Ç—ã –º–µ—Ç—Ä–∏–∫
                this.metrics.entropy = Number(this.metrics.entropy.toFixed(2));
                this.metrics.avalanche = Number(this.metrics.avalanche.toFixed(1));
            }
        }

        // =============================================================================
        // –ò–ù–¢–ï–†–§–ï–ô–° –ò –£–ü–†–ê–í–õ–ï–ù–ò–ï
        // =============================================================================

        const cryptoSystem = new ProfessionalCryptoSystem();

        async function initializeSystem() {
            const fieldSize = parseInt(document.getElementById('field-size').value);
            const key = document.getElementById('crypto-key').value;
            
            updateStatus('sbox', 'warning', '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è...');
            updateStatus('crypto', 'warning', '–ù–∞—Å—Ç—Ä–æ–π–∫–∞...');
            updateStatus('homo', 'warning', '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...');
            
            const success = await cryptoSystem.initializeSystem(fieldSize, key);
            
            if (success) {
                updateStatus('sbox', 'active', '–ê–∫—Ç–∏–≤–µ–Ω');
                updateStatus('crypto', 'active', '–ì–æ—Ç–æ–≤');
                updateStatus('homo', 'active', '–†–∞–±–æ—Ç–∞–µ—Ç');
                updateStatus('test', 'active', '–¢–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã');
                
                updateTestResults();
                updateMetrics();
            } else {
                updateStatus('sbox', 'danger', '–û—à–∏–±–∫–∞');
                updateStatus('crypto', 'danger', '–û—à–∏–±–∫–∞');
                updateStatus('homo', 'danger', '–û—à–∏–±–∫–∞');
            }
        }

        async function performHomomorphicAddition() {
            try {
                const a = parseInt(document.getElementById('input-a').value);
                const b = parseInt(document.getElementById('input-b').value);
                
                // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
                const encA = await cryptoSystem.encrypt(a);
                const encB = await cryptoSystem.encrypt(b);
                
                // –ì–æ–º–æ–º–æ—Ä—Ñ–Ω–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ
                const encSum = await cryptoSystem.homomorphicAdd(encA, encB);
                
                // –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞
                const result = await cryptoSystem.decrypt(encSum);
                
                // –í—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                document.getElementById('operation-result').innerHTML = `
                    <div>A = ${a} ‚Üí –®–∏—Ñ—Ä: ${encA}</div>
                    <div>B = ${b} ‚Üí –®–∏—Ñ—Ä: ${encB}</div>
                    <div>–°—É–º–º–∞ –≤ —à–∏—Ñ—Ä–µ: ${encSum}</div>
                    <div>–†–µ–∑—É–ª—å—Ç–∞—Ç: ${result} (–æ–∂–∏–¥–∞–ª–æ—Å—å: ${a + b})</div>
                    <div>${result === a + b ? '‚úÖ –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ' : '‚ùå –û—à–∏–±–∫–∞'}</div>
                `;
                
            } catch (error) {
                document.getElementById('operation-result').textContent = 
                    `–û—à–∏–±–∫–∞: ${error.message}`;
                cryptoSystem.metrics.errors++;
                updateMetrics();
            }
        }

        async function runAllTests() {
            updateStatus('test', 'warning', '–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ...');
            
            await cryptoSystem.runInitialTests();
            updateTestResults();
            updateMetrics();
            
            updateStatus('test', 'active', '–¢–µ—Å—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã');
        }

        async function testReversibility() {
            const result = await cryptoSystem.testReversibility();
            updateTestResult('reversibility', result);
        }

        async function testHomomorphicProperties() {
            const result = await cryptoSystem.testHomomorphicProperties();
            updateTestResult('homomorphic', result);
        }

        async function testCryptographicSecurity() {
            const result = await cryptoSystem.testSecurity();
            updateTestResult('security', result);
        }

        function updateTestResult(testName, result) {
            const testElement = document.querySelector(`#test-results .test-result:nth-child(${
                testName === 'reversibility' ? 1 : 
                testName === 'homomorphic' ? 2 : 
                testName === 'security' ? 3 : 4
            })`);
            
            if (testElement) {
                testElement.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                testElement.innerHTML = `${result.passed ? '‚úÖ' : '‚ùå'} ${testName}: ${result.message}`;
            }
        }

        function updateTestResults() {
            updateTestResult('reversibility', cryptoSystem.testResults.reversibility);
            updateTestResult('homomorphic', cryptoSystem.testResults.homomorphic);
            updateTestResult('security', cryptoSystem.testResults.security);
            updateTestResult('performance', cryptoSystem.testResults.performance);
        }

        function updateMetrics() {
            document.getElementById('metric-entropy').textContent = cryptoSystem.metrics.entropy;
            document.getElementById('metric-avalanche').textContent = cryptoSystem.metrics.avalanche + '%';
            document.getElementById('metric-speed').textContent = cryptoSystem.metrics.speed;
            document.getElementById('metric-errors').textContent = cryptoSystem.metrics.errors;
        }

        function updateStatus(element, status, text) {
            const indicator = document.getElementById(`status-${element}-indicator`);
            const textElement = document.getElementById(`status-${element}`);
            
            indicator.className = `status-indicator status-${status}`;
            textElement.textContent = text;
        }

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', () => {
            updateStatus('sbox', 'danger', '–ù–µ–∏–Ω–∏—Ü');
            updateStatus('crypto', 'danger', '–û—Ç–∫–ª');
            updateStatus('homo', 'danger', '–û—Ç–∫–ª');
            updateStatus('test', 'danger', '–ù–µ –∑–∞–ø—É—â–µ–Ω—ã');
        });
    </script>
</body>
</html>
