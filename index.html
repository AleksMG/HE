<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Omophonic Crypto System</title>
    <style>
        :root {
            --primary: #0a0a0a;
            --secondary: #1a1a1a;
            --accent: #2d2d2d;
            --success: #00cc88;
            --warning: #ffaa00;
            --danger: #ff4444;
            --background: #000000;
            --surface: #111111;
            --text: #ffffff;
            --border: #333333;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'IBM Plex Mono', 'JetBrains Mono', monospace;
        }

        body {
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: var(--surface);
            color: var(--text);
            padding: 2rem;
            text-align: center;
            border: 1px solid var(--border);
            margin-bottom: 2rem;
            border-radius: 8px;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
            color: var(--success);
        }

        .grid-system {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
        }

        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 20px;
        }

        .panel-header {
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border);
        }

        .panel-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--success);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            background: var(--accent);
            color: var(--text);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            background: var(--success);
            color: var(--background);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text);
            font-size: 0.9rem;
        }

        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 0.9rem;
        }

        .result-area {
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .test-result {
            padding: 0.75rem;
            margin: 0.5rem 0;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .test-pass {
            background: rgba(0, 204, 136, 0.1);
            border-left: 4px solid var(--success);
            color: var(--success);
        }

        .test-fail {
            background: rgba(255, 68, 68, 0.1);
            border-left: 4px solid var(--danger);
            color: var(--danger);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-active { background: var(--success); }
        .status-warning { background: var(--warning); }
        .status-danger { background: var(--danger); }

        .operation-flow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 1rem 0;
            padding: 1rem;
            background: var(--background);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .operation-step {
            text-align: center;
            padding: 0.5rem;
            flex: 1;
            font-size: 0.9rem;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .metric-box {
            padding: 1rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--background);
            text-align: center;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--success);
            margin: 0.5rem 0;
        }

        .log-entry {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîê PROFESSIONAL OMOPHONIC CRYPTO SYSTEM</h1>
            <p>256 bytes ‚Üí 65536 omophones | Homomorphic Encryption with Diffusion</p>
        </header>

        <div class="grid-system">
            <!-- Left Panel -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">‚öôÔ∏è CONFIGURATION</h3>
                    </div>
                    
                    <div class="form-group">
                        <label>Key Derivation Iterations:</label>
                        <input type="number" id="key-iterations" value="100000" min="10000">
                    </div>

                    <div class="form-group">
                        <label>Crypto Key:</label>
                        <input type="password" id="crypto-key" value="super-strong-256-bit-key-omophonic">
                    </div>

                    <div class="form-group">
                        <label>Galois Field Prime:</label>
                        <input type="number" id="galois-prime" value="65521" min="32768" max="65535">
                    </div>

                    <button class="btn" onclick="initializeSystem()">
                        üöÄ INITIALIZE SYSTEM
                    </button>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üß™ TESTING</h3>
                    </div>
                    
                    <button class="btn" onclick="runAllTests()">
                        ‚úÖ RUN ALL TESTS
                    </button>

                    <button class="btn" onclick="testReversibility()">
                        üîÑ TEST REVERSIBILITY
                    </button>

                    <button class="btn" onclick="testHomomorphicProperties()">
                        üßÆ TEST HOMOMORPHISM
                    </button>

                    <button class="btn" onclick="testCryptographicSecurity()">
                        üîí TEST SECURITY
                    </button>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üìä SYSTEM STATUS</h3>
                    </div>
                    
                    <div class="result-area">
                        <div><span class="status-indicator" id="status-sbox-indicator"></span>S-Box: <span id="status-sbox">NOT INIT</span></div>
                        <div><span class="status-indicator" id="status-crypto-indicator"></span>Cryptography: <span id="status-crypto">OFF</span></div>
                        <div><span class="status-indicator" id="status-homo-indicator"></span>Homomorphism: <span id="status-homo">OFF</span></div>
                        <div><span class="status-indicator" id="status-test-indicator"></span>Tests: <span id="status-test">NOT RUN</span></div>
                    </div>
                </div>
            </div>

            <!-- Right Panel -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üî¢ OPERATIONS</h3>
                    </div>
                    
                    <div class="form-group">
                        <label>Value A (0-255):</label>
                        <input type="number" id="input-a" value="42" min="0" max="255">
                    </div>

                    <div class="form-group">
                        <label>Value B (0-255):</label>
                        <input type="number" id="input-b" value="17" min="0" max="255">
                    </div>

                    <div class="operation-flow">
                        <div class="operation-step">A ‚Üí Encrypt ‚Üí</div>
                        <div class="operation-step" style="font-size: 1.5rem;">+</div>
                        <div class="operation-step">B ‚Üí Encrypt ‚Üí</div>
                        <div class="operation-step" style="font-size: 1.5rem;">=</div>
                        <div class="operation-step">‚Üê Decrypt ‚Üê</div>
                    </div>

                    <button class="btn" onclick="performHomomorphicAddition()">
                        ‚ûï PERFORM ADDITION
                    </button>

                    <div class="result-area" id="operation-result">
                        Results will appear here...
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üìà TEST RESULTS</h3>
                    </div>
                    
                    <div class="result-area" id="test-results">
                        <div class="test-result test-fail">‚ùå Reversibility: NOT TESTED</div>
                        <div class="test-result test-fail">‚ùå Homomorphism: NOT TESTED</div>
                        <div class="test-result test-fail">‚ùå Security: NOT TESTED</div>
                        <div class="test-result test-fail">‚ùå Performance: NOT TESTED</div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üìä SYSTEM METRICS</h3>
                    </div>
                    
                    <div class="metric-grid">
                        <div class="metric-box">
                            <div>Entropy</div>
                            <div class="metric-value" id="metric-entropy">0.00</div>
                            <div>bits/byte</div>
                        </div>
                        <div class="metric-box">
                            <div>Avalanche Effect</div>
                            <div class="metric-value" id="metric-avalanche">0%</div>
                            <div>bit change</div>
                        </div>
                        <div class="metric-box">
                            <div>Speed</div>
                            <div class="metric-value" id="metric-speed">0</div>
                            <div>ops/sec</div>
                        </div>
                        <div class="metric-box">
                            <div>Errors</div>
                            <div class="metric-value" id="metric-errors">0</div>
                            <div>count</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =============================================================================
        // GALOIS FIELD OPERATIONS
        // =============================================================================

        class GaloisField {
            constructor(prime) {
                this.prime = prime;
                this.inverseCache = new Map();
            }

            add(a, b) {
                return (a + b) % this.prime;
            }

            subtract(a, b) {
                return (a - b + this.prime) % this.prime;
            }

            multiply(a, b) {
                return Number((BigInt(a) * BigInt(b)) % BigInt(this.prime));
            }

            divide(a, b) {
                if (b === 0) throw new Error("Division by zero");
                const inv = this.inverse(b);
                return this.multiply(a, inv);
            }

            inverse(a) {
                if (this.inverseCache.has(a)) {
                    return this.inverseCache.get(a);
                }
                
                // Extended Euclidean algorithm
                let t = 0, newT = 1;
                let r = this.prime, newR = a;
                
                while (newR !== 0) {
                    const quotient = Math.floor(r / newR);
                    [t, newT] = [newT, t - quotient * newT];
                    [r, newR] = [newR, r - quotient * newR];
                }
                
                if (r > 1) throw new Error("Element not invertible");
                if (t < 0) t += this.prime;
                
                this.inverseCache.set(a, t);
                return t;
            }

            sqrt(a) {
                // Tonelli-Shanks algorithm for square roots in finite field
                if (a === 0) return 0;
                
                // Check if a is quadratic residue
                if (this.pow(a, (this.prime - 1) / 2) !== 1) {
                    throw new Error("No square root found");
                }
                
                let q = this.prime - 1;
                let s = 0;
                while (q % 2 === 0) {
                    q /= 2;
                    s++;
                }
                
                let z = 2;
                while (this.pow(z, (this.prime - 1) / 2) !== this.prime - 1) {
                    z++;
                }
                
                let c = this.pow(z, q);
                let x = this.pow(a, (q + 1) / 2);
                let t = this.pow(a, q);
                let m = s;
                
                while (t !== 1) {
                    let i = 0, tt = t;
                    while (tt !== 1 && i < m) {
                        tt = this.multiply(tt, tt);
                        i++;
                    }
                    
                    const b = this.pow(c, 1 << (m - i - 1));
                    x = this.multiply(x, b);
                    t = this.multiply(t, this.multiply(b, b));
                    c = this.multiply(b, b);
                    m = i;
                }
                
                return x;
            }

            pow(base, exponent) {
                let result = 1;
                base = base % this.prime;
                
                while (exponent > 0) {
                    if (exponent % 2 === 1) {
                        result = this.multiply(result, base);
                    }
                    exponent = Math.floor(exponent / 2);
                    base = this.multiply(base, base);
                }
                
                return result;
            }
        }

        // =============================================================================
        // PROFESSIONAL OMOPHONIC CRYPTO SYSTEM
        // =============================================================================

        class ProfessionalOmophonicCrypto {
            constructor() {
                this.initialized = false;
                this.sBox = new Map();
                this.inverseSBox = new Map();
                this.keyMaterial = null;
                this.omophoneCount = 256;
                this.iv = null;
                this.previousOmophone = 0;
                this.galoisField = null;
                
                this.testResults = {
                    reversibility: { passed: false, message: "Not tested" },
                    homomorphic: { passed: false, message: "Not tested" },
                    security: { passed: false, message: "Not tested" },
                    performance: { passed: false, message: "Not tested" }
                };
                
                this.metrics = {
                    entropy: 0,
                    avalanche: 0,
                    speed: 0,
                    errors: 0
                };
            }

            // =============================================================================
            // CORE METHODS
            // =============================================================================

            async initializeSystem(key, iterations = 100000, galoisPrime = 65521) {
                try {
                    console.log("üîß Initializing omophonic system...");
                    
                    // Initialize Galois Field
                    this.galoisField = new GaloisField(galoisPrime);
                    
                    // Derive key material
                    this.keyMaterial = await this.deriveKey(key, iterations);
                    
                    // Generate S-Box 256√ó256
                    await this.generateSBox();
                    
                    // Initialize IV for CBC mode
                    await this.initializeIV();
                    
                    // Run initial tests
                    await this.runInitialTests();
                    
                    this.initialized = true;
                    console.log("‚úÖ System successfully initialized");
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå Initialization error:', error);
                    this.metrics.errors++;
                    return false;
                }
            }

            async deriveKey(key, iterations) {
                const encoder = new TextEncoder();
                const keyBuffer = encoder.encode(key);
                
                const salt = crypto.getRandomValues(new Uint8Array(16));
                
                const importedKey = await crypto.subtle.importKey(
                    'raw', keyBuffer, { name: 'PBKDF2' }, false, ['deriveBits']
                );
                
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: iterations,
                        hash: 'SHA-512'
                    },
                    importedKey,
                    512
                );
                
                return new Uint8Array(derivedBits);
            }

            async generateSBox() {
                this.sBox.clear();
                this.inverseSBox.clear();
                
                console.log("üîÑ Generating 256√ó256 S-Box...");
                
                for (let byteValue = 0; byteValue < 256; byteValue++) {
                    const omophones = new Uint16Array(256);
                    const usedOmophones = new Set();
                    
                    for (let omoIndex = 0; omoIndex < 256; omoIndex++) {
                        let omophone;
                        let attempts = 0;
                        
                        do {
                            omophone = await this.generateUniqueOmophone(byteValue, omoIndex);
                            attempts++;
                            
                            if (attempts > 1000) {
                                throw new Error(`Failed to generate unique omophone for byte ${byteValue}`);
                            }
                            
                        } while (usedOmophones.has(omophone) || this.inverseSBox.has(omophone));
                        
                        omophones[omoIndex] = omophone;
                        usedOmophones.add(omophone);
                        this.inverseSBox.set(omophone, byteValue);
                    }
                    
                    this.sBox.set(byteValue, omophones);
                    
                    if (byteValue % 32 === 0) {
                        console.log(`üìä Progress: ${((byteValue / 255) * 100).toFixed(1)}%`);
                    }
                }
                
                console.log("‚úÖ S-Box successfully generated");
            }

            async generateUniqueOmophone(byteValue, index) {
                const seedData = new TextEncoder().encode(
                    `${byteValue}-${index}-${Array.from(this.keyMaterial).join('-')}`
                );
                
                const hash = await crypto.subtle.digest('SHA-256', seedData);
                const hashArray = new Uint8Array(hash);
                
                let omophone = 0;
                for (let i = 0; i < hashArray.length - 1; i += 2) {
                    omophone = (omophone ^ (hashArray[i] << 8 | hashArray[i + 1])) & 0xFFFF;
                }
                
                return omophone;
            }

            async initializeIV() {
                this.iv = crypto.getRandomValues(new Uint16Array(1))[0];
                this.previousOmophone = this.iv;
            }

            // =============================================================================
            // ENCRYPTION WITH DIFFUSION
            // =============================================================================

            async encryptByte(byteValue, previousBlock = 0) {
                if (byteValue < 0 || byteValue > 255) {
                    throw new Error("Byte must be in range 0-255");
                }
                
                const baseOmophone = await this.getRandomOmophone(byteValue);
                const cbcMixed = baseOmophone ^ previousBlock;
                const diffused = await this.applyMixingRound(cbcMixed, byteValue);
                
                this.previousOmophone = diffused;
                return diffused;
            }

            async decryptOmophone(omophone, previousBlock = 0) {
                if (!this.initialized) throw new Error("System not initialized");
                
                const reversedMix = await this.reverseMixingRound(omophone, previousBlock);
                const baseOmophone = reversedMix ^ previousBlock;
                
                const result = this.inverseSBox.get(baseOmophone);
                if (result === undefined) {
                    throw new Error(`Unknown omophone: ${omophone}`);
                }
                
                return result;
            }

            async getRandomOmophone(byteValue) {
                const omophones = this.sBox.get(byteValue);
                if (!omophones) {
                    throw new Error(`Byte ${byteValue} not found in S-Box`);
                }
                
                const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0];
                return omophones[randomIndex];
            }

            // =============================================================================
            // MIXING ROUNDS WITH GALOIS FIELD OPERATIONS
            // =============================================================================

            async applyMixingRound(value, byteIndex) {
                let mixed = value;
                
                // Round 1: Nonlinear transformation
                mixed = this.galoisField.multiply(mixed, mixed);
                mixed = this.galoisField.add(mixed, byteIndex * 17);
                
                // Round 2: Key-dependent multiplication
                const keyPart = this.keyMaterial[byteIndex % this.keyMaterial.length];
                mixed = this.galoisField.multiply(mixed, keyPart + 1);
                
                // Round 3: Bit rotations
                mixed = this.bitRotateLeft(mixed, 5) ^ this.bitRotateRight(mixed, 3);
                
                return mixed % 65536;
            }

            async reverseMixingRound(value, byteIndex) {
                let mixed = value;
                
                // Reverse round 3: Bit rotations
                mixed = this.bitRotateRight(mixed, 5) ^ this.bitRotateLeft(mixed, 3);
                
                // Reverse round 2: Key-dependent division
                const keyPart = this.keyMaterial[byteIndex % this.keyMaterial.length];
                mixed = this.galoisField.divide(mixed, keyPart + 1);
                
                // Reverse round 1: Nonlinear transformation
                mixed = this.galoisField.subtract(mixed, byteIndex * 17);
                mixed = this.galoisField.sqrt(mixed);
                
                return mixed;
            }

            bitRotateLeft(value, shift) {
                return ((value << shift) | (value >>> (16 - shift))) & 0xFFFF;
            }

            bitRotateRight(value, shift) {
                return ((value >>> shift) | (value << (16 - shift))) & 0xFFFF;
            }

            // =============================================================================
            // HOMOMORPHIC OPERATIONS
            // =============================================================================

            async homomorphicAdd(omoA, omoB) {
                return this.galoisField.add(omoA, omoB);
            }

            async homomorphicMultiply(omoA, omoB) {
                return this.galoisField.multiply(omoA, omoB);
            }

            // =============================================================================
            // DATA OPERATIONS
            // =============================================================================

            async encryptData(data) {
                const encoder = new TextEncoder();
                const dataBuffer = encoder.encode(data);
                const encryptedBlocks = [this.iv];
                
                for (let i = 0; i < dataBuffer.length; i++) {
                    const previousBlock = encryptedBlocks[encryptedBlocks.length - 1];
                    const encrypted = await this.encryptByte(dataBuffer[i], previousBlock);
                    encryptedBlocks.push(encrypted);
                }
                
                return encryptedBlocks;
            }

            async decryptData(encryptedBlocks) {
                const decryptedBytes = [];
                const iv = encryptedBlocks[0];
                
                for (let i = 1; i < encryptedBlocks.length; i++) {
                    const previousBlock = i === 1 ? iv : encryptedBlocks[i - 1];
                    const decrypted = await this.decryptOmophone(encryptedBlocks[i], previousBlock);
                    decryptedBytes.push(decrypted);
                }
                
                const decoder = new TextDecoder();
                return decoder.decode(new Uint8Array(decryptedBytes));
            }

            // =============================================================================
            // TESTING AND VERIFICATION
            // =============================================================================

            async runInitialTests() {
                this.testResults.reversibility = await this.testReversibility();
                this.testResults.homomorphic = await this.testHomomorphicProperties();
                this.testResults.security = await this.testSecurity();
                this.testResults.performance = await this.testPerformance();
                
                await this.calculateMetrics();
            }

            async testReversibility() {
                const testCases = 1000;
                let passed = 0;
                
                for (let i = 0; i < testCases; i++) {
                    try {
                        const testValue = Math.floor(Math.random() * 256);
                        const encrypted = await this.encryptByte(testValue, this.iv);
                        const decrypted = await this.decryptOmophone(encrypted, this.iv);
                        
                        if (decrypted === testValue) {
                            passed++;
                        }
                    } catch (error) {
                        console.error("Error in reversibility test:", error);
                    }
                }
                
                return {
                    passed: passed === testCases,
                    message: `${passed}/${testCases} tests passed`
                };
            }

            async testHomomorphicProperties() {
                const testCases = 100;
                let passed = 0;
                
                for (let i = 0; i < testCases; i++) {
                    try {
                        const a = Math.floor(Math.random() * 100);
                        const b = Math.floor(Math.random() * 100);
                        
                        const encA = await this.encryptByte(a, this.iv);
                        const encB = await this.encryptByte(b, this.iv);
                        
                        const encSum = await this.homomorphicAdd(encA, encB);
                        const decryptedSum = await this.decryptOmophone(encSum, this.iv);
                        const expectedSum = (a + b) % 256;
                        
                        if (decryptedSum === expectedSum) {
                            passed++;
                        }
                    } catch (error) {
                        console.error("Error in homomorphism test:", error);
                    }
                }
                
                return {
                    passed: passed === testCases,
                    message: `${passed}/${testCases} tests passed`
                };
            }

            async testSecurity() {
                const avalancheResult = await this.testAvalancheEffect();
                const entropyResult = await this.testEntropy();
                
                return {
                    passed: avalancheResult && entropyResult,
                    message: `Avalanche: ${avalancheResult ? '‚úì' : '‚úó'}, Entropy: ${entropyResult ? '‚úì' : '‚úó'}`
                };
            }

            async testAvalancheEffect() {
                const testCases = 1000;
                let totalChange = 0;
                
                for (let i = 0; i < testCases; i++) {
                    const input1 = Math.floor(Math.random() * 256);
                    const input2 = (input1 + 1) % 256;
                    
                    const omo1 = await this.encryptByte(input1, this.iv);
                    const omo2 = await this.encryptByte(input2, this.iv);
                    
                    const diff = omo1 ^ omo2;
                    let changedBits = 0;
                    for (let j = 0; j < 16; j++) {
                        if (diff & (1 << j)) {
                            changedBits++;
                        }
                    }
                    
                    totalChange += (changedBits / 16) * 100;
                }
                
                const avgChange = totalChange / testCases;
                this.metrics.avalanche = avgChange;
                
                return avgChange > 45 && avgChange < 55;
            }

            async testEntropy() {
                const samples = 10000;
                const frequency = new Map();
                
                for (let i = 0; i < samples; i++) {
                    const value = Math.floor(Math.random() * 256);
                    const encrypted = await this.encryptByte(value, this.iv);
                    
                    frequency.set(encrypted, (frequency.get(encrypted) || 0) + 1);
                }
                
                let entropy = 0;
                const total = samples;
                
                for (const count of frequency.values()) {
                    const probability = count / total;
                    entropy -= probability * Math.log2(probability);
                }
                
                this.metrics.entropy = entropy;
                
                return entropy > 15;
            }

            async testPerformance() {
                const startTime = performance.now();
                const operations = 1000;
                
                for (let i = 0; i < operations; i++) {
                    const value = Math.floor(Math.random() * 256);
                    await this.encryptByte(value, this.iv);
                }
                
                const endTime = performance.now();
                const opsPerSecond = operations / ((endTime - startTime) / 1000);
                
                this.metrics.speed = Math.round(opsPerSecond);
                return opsPerSecond > 10;
            }

            async calculateMetrics() {
                this.metrics.entropy = Number(this.metrics.entropy.toFixed(2));
                this.metrics.avalanche = Number(this.metrics.avalanche.toFixed(1));
            }
        }

        // =============================================================================
        // UI MANAGEMENT
        // =============================================================================

        const cryptoSystem = new ProfessionalOmophonicCrypto();

        async function initializeSystem() {
            const iterations = parseInt(document.getElementById('key-iterations').value);
            const key = document.getElementById('crypto-key').value;
            const galoisPrime = parseInt(document.getElementById('galois-prime').value);
            
            updateStatus('sbox', 'warning', 'Generating...');
            updateStatus('crypto', 'warning', 'Setting up...');
            updateStatus('homo', 'warning', 'Initializing...');
            
            const success = await cryptoSystem.initializeSystem(key, iterations, galoisPrime);
            
            if (success) {
                updateStatus('sbox', 'active', 'Active');
                updateStatus('crypto', 'active', 'Ready');
                updateStatus('homo', 'active', 'Operational');
                updateStatus('test', 'active', 'Tests passed');
                
                updateTestResults();
                updateMetrics();
            } else {
                updateStatus('sbox', 'danger', 'Error');
                updateStatus('crypto', 'danger', 'Error');
                updateStatus('homo', 'danger', 'Error');
            }
        }

        async function performHomomorphicAddition() {
            try {
                const a = parseInt(document.getElementById('input-a').value);
                const b = parseInt(document.getElementById('input-b').value);
                
                if (a < 0 || a > 255 || b < 0 || b > 255) {
                    throw new Error("Values must be between 0 and 255");
                }
                
                const encA = await cryptoSystem.encryptByte(a, cryptoSystem.iv);
                const encB = await cryptoSystem.encryptByte(b, cryptoSystem.iv);
                
                const encSum = await cryptoSystem.homomorphicAdd(encA, encB);
                const result = await cryptoSystem.decryptOmophone(encSum, cryptoSystem.iv);
                const expected = (a + b) % 256;
                
                document.getElementById('operation-result').innerHTML = `
                    <div>A = ${a} ‚Üí Encrypted: ${encA}</div>
                    <div>B = ${b} ‚Üí Encrypted: ${encB}</div>
                    <div>Encrypted Sum: ${encSum}</div>
                    <div>Result: ${result} (expected: ${expected})</div>
                    <div>${result === expected ? '‚úÖ Correct' : '‚ùå Error'}</div>
                `;
                
            } catch (error) {
                document.getElementById('operation-result').textContent = 
                    `Error: ${error.message}`;
                cryptoSystem.metrics.errors++;
                updateMetrics();
            }
        }

        async function runAllTests() {
            updateStatus('test', 'warning', 'Testing...');
            
            await cryptoSystem.runInitialTests();
            updateTestResults();
            updateMetrics();
            
            updateStatus('test', 'active', 'Tests completed');
        }

        async function testReversibility() {
            const result = await cryptoSystem.testReversibility();
            updateTestResult('reversibility', result);
        }

        async function testHomomorphicProperties() {
            const result = await cryptoSystem.testHomomorphicProperties();
            updateTestResult('homomorphic', result);
        }

        async function testCryptographicSecurity() {
            const result = await cryptoSystem.testSecurity();
            updateTestResult('security', result);
        }

        function updateTestResult(testName, result) {
            const testElement = document.querySelector(`#test-results .test-result:nth-child(${
                testName === 'reversibility' ? 1 : 
                testName === 'homomorphic' ? 2 : 
                testName === 'security' ? 3 : 4
            })`);
            
            if (testElement) {
                testElement.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                testElement.innerHTML = `${result.passed ? '‚úÖ' : '‚ùå'} ${testName}: ${result.message}`;
            }
        }

        function updateTestResults() {
            updateTestResult('reversibility', cryptoSystem.testResults.reversibility);
            updateTestResult('homomorphic', cryptoSystem.testResults.homomorphic);
            updateTestResult('security', cryptoSystem.testResults.security);
            updateTestResult('performance', cryptoSystem.testResults.performance);
        }

        function updateMetrics() {
            document.getElementById('metric-entropy').textContent = cryptoSystem.metrics.entropy;
            document.getElementById('metric-avalanche').textContent = cryptoSystem.metrics.avalanche + '%';
            document.getElementById('metric-speed').textContent = cryptoSystem.metrics.speed;
            document.getElementById('metric-errors').textContent = cryptoSystem.metrics.errors;
        }

        function updateStatus(element, status, text) {
            const indicator = document.getElementById(`status-${element}-indicator`);
            const textElement = document.getElementById(`status-${element}`);
            
            indicator.className = `status-indicator status-${status}`;
            textElement.textContent = text;
        }

        // Auto-initialization
        window.addEventListener('load', () => {
            updateStatus('sbox', 'danger', 'Not init');
            updateStatus('crypto', 'danger', 'Off');
            updateStatus('homo', 'danger', 'Off');
            updateStatus('test', 'danger', 'Not run');
        });
    </script>
</body>
</html>
