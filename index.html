<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homomorphic Encryption System</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --background: #0f172a;
            --surface: #1e293b;
            --text: #f8fafc;
            --border: #334155;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
        }
        
        body {
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 2rem;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        header {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            color: #94a3b8;
            font-size: 1.1rem;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
        }
        
        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary);
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #e2e8f0;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            background: rgba(15, 23, 42, 0.6);
            color: var(--text);
            font-size: 1rem;
            transition: all 0.2s ease;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
        }
        
        .btn-group {
            display: flex;
            gap: 1rem;
            margin: 1.5rem 0;
        }
        
        button {
            flex: 1;
            padding: 0.875rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: var(--secondary);
            color: white;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #0d9669;
            transform: translateY(-1px);
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        
        .result-container {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }
        
        .result-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .result-title {
            font-weight: 600;
            color: var(--secondary);
        }
        
        .result-content {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            word-break: break-all;
            white-space: pre-wrap;
        }
        
        .status-indicator {
            display: inline-block;
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        
        .status-ready { background: var(--secondary); }
        .status-processing { background: var(--warning); }
        .status-error { background: var(--danger); }
        
        .footer {
            text-align: center;
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
            color: #94a3b8;
            font-size: 0.9rem;
        }
        
        .loading {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .output-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .output-preview {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.4);
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }

        .test-result {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-radius: 0.25rem;
            background: rgba(15, 23, 42, 0.4);
        }
        
        .test-pass {
            border-left: 4px solid var(--secondary);
        }
        
        .test-fail {
            border-left: 4px solid var(--danger);
        }
        
        .test-warning {
            border-left: 4px solid var(--warning);
        }
        
        .test-info {
            border-left: 4px solid var(--primary);
        }
        
        .advanced-options {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.4);
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }
        
        .option-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .option-label {
            flex: 1;
            font-size: 0.9rem;
        }
        
        .option-control {
            flex: 2;
        }
        
        .homomorphic-operations {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }
        
        .operation-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .encrypted-data {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin: 0.25rem 0;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Homomorphic Encryption System</h1>
            <p class="subtitle">Perform computations on encrypted data without decryption</p>
        </header>

        <div class="grid">
            <div class="card">
                <h2 class="card-title">Encryption Parameters</h2>
                
                <div class="form-group">
                    <label for="keySize">Key Size (bits):</label>
                    <select id="keySize">
                        <option value="128">128 bits (Testing)</option>
                        <option value="256" selected>256 bits (Standard)</option>
                        <option value="512">512 bits (Secure)</option>
                        <option value="1024">1024 bits (High Security)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="dataType">Data Type:</label>
                    <select id="dataType">
                        <option value="numbers" selected>Numbers</option>
                        <option value="text">Text</option>
                    </select>
                </div>

                <div class="advanced-options">
                    <h3 style="margin-bottom: 1rem; color: var(--primary);">Advanced Options</h3>
                    
                    <div class="option-row">
                        <div class="option-label">Debug Mode:</div>
                        <div class="option-control">
                            <input type="checkbox" id="debugMode">
                        </div>
                    </div>
                    
                    <div class="option-row">
                        <div class="option-label">Auto Test:</div>
                        <div class="option-control">
                            <input type="checkbox" id="autoTest" checked>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Key Generation:</label>
                    <button id="generateKeys" class="btn-primary">Generate Key Pair</button>
                </div>
                
                <div class="result-container">
                    <div class="result-header">
                        <span class="result-title">Public Key:</span>
                    </div>
                    <div id="publicKey" class="result-content">Not generated yet</div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">Data Processing</h2>
                
                <div class="form-group">
                    <label for="inputData">Input Data (comma-separated numbers or text):</label>
                    <textarea id="inputData" placeholder="Enter data to process">10, 20, 30</textarea>
                </div>
                
                <div class="btn-group">
                    <button id="encryptBtn" class="btn-primary">
                        <span class="loading" id="encryptLoading" style="display: none;"></span>
                        Encrypt Data
                    </button>
                    <button id="decryptBtn" class="btn-secondary">
                        <span class="loading" id="decryptLoading" style="display: none;"></span>
                        Decrypt Data
                    </button>
                </div>
                
                <div class="result-container">
                    <div class="result-header">
                        <span class="result-title">Encrypted Data:</span>
                    </div>
                    <div id="encryptedData" class="result-content"></div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 class="card-title">Homomorphic Operations</h2>
            
            <div class="operation-controls">
                <div class="form-group">
                    <label for="operand">Operand (number):</label>
                    <input type="number" id="operand" value="5">
                </div>
                
                <div class="form-group">
                    <label for="operation">Operation:</label>
                    <select id="operation">
                        <option value="add">Addition (E(a) + b = E(a+b))</option>
                        <option value="multiply">Multiplication (E(a) * b = E(a*b))</option>
                        <option value="add_encrypted">Encrypted Addition (E(a) + E(b) = E(a+b))</option>
                    </select>
                </div>
            </div>
            
            <button id="computeBtn" class="btn-secondary">Compute on Encrypted Data</button>
            
            <div class="result-container">
                <div class="result-header">
                    <span class="result-title">Operation Result:</span>
                </div>
                <div id="operationResult" class="result-content"></div>
            </div>
            
            <div class="result-container" style="margin-top: 1rem;">
                <div class="result-header">
                    <span class="result-title">Decrypted Result:</span>
                </div>
                <div id="decryptedResult" class="result-content"></div>
            </div>
        </div>

        <div class="card">
            <h2 class="card-title">ðŸ”¬ Cryptographic Tests</h2>
            
            <div class="result-container">
                <div class="result-header">
                    <span class="result-title">Test Results:</span>
                    <span id="testStatus" class="status-ready">Ready to test</span>
                </div>
                <div id="testResults" class="result-content"></div>
            </div>
            
            <button id="runTests" class="btn-secondary">Run Comprehensive Tests</button>
        </div>

        <div class="footer">
            <p>Homomorphic Encryption System v1.0 | Paillier Cryptosystem Implementation</p>
            <p>Â© 2024 Cryptographic Systems | All operations performed client-side</p>
        </div>
    </div>

    <script>
        // Big integer utilities for working with large numbers
        class BigIntUtils {
            static generateRandomBigInt(bitLength) {
                const byteLength = Math.ceil(bitLength / 8);
                const randomBytes = new Uint8Array(byteLength);
                crypto.getRandomValues(randomBytes);
                
                // Ensure the number has the correct bit length
                const bitsToClear = (byteLength * 8) - bitLength;
                if (bitsToClear > 0) {
                    randomBytes[0] &= (0xFF >> bitsToClear);
                }
                
                // Set the highest bit to ensure correct bit length
                randomBytes[0] |= (0x80 >> bitsToClear);
                
                let result = 0n;
                for (let i = 0; i < randomBytes.length; i++) {
                    result = (result << 8n) + BigInt(randomBytes[i]);
                }
                
                return result;
            }
            
            static modPow(base, exponent, modulus) {
                if (modulus === 1n) return 0n;
                let result = 1n;
                base = base % modulus;
                
                while (exponent > 0n) {
                    if (exponent % 2n === 1n) {
                        result = (result * base) % modulus;
                    }
                    exponent = exponent >> 1n;
                    base = (base * base) % modulus;
                }
                
                return result;
            }
            
            static modInverse(a, m) {
                let [old_r, r] = [a, m];
                let [old_s, s] = [1n, 0n];
                let [old_t, t] = [0n, 1n];
                
                while (r !== 0n) {
                    const quotient = old_r / r;
                    [old_r, r] = [r, old_r - quotient * r];
                    [old_s, s] = [s, old_s - quotient * s];
                    [old_t, t] = [t, old_t - quotient * t];
                }
                
                if (old_s < 0n) old_s += m;
                return old_s;
            }
            
            static gcd(a, b) {
                while (b !== 0n) {
                    [a, b] = [b, a % b];
                }
                return a;
            }
            
            static isProbablyPrime(n, k = 20) {
                if (n === 2n || n === 3n) return true;
                if (n <= 1n || n % 2n === 0n) return false;
                
                // Write n as 2^s * d + 1
                let s = 0n;
                let d = n - 1n;
                while (d % 2n === 0n) {
                    d /= 2n;
                    s += 1n;
                }
                
                // Witness loop
                for (let i = 0; i < k; i++) {
                    const a = this.generateRandomBigInt(Number(n.toString(2).length - 1)) % (n - 2n) + 2n;
                    let x = this.modPow(a, d, n);
                    
                    if (x === 1n || x === n - 1n) continue;
                    
                    let continueLoop = false;
                    for (let j = 0n; j < s - 1n; j++) {
                        x = this.modPow(x, 2n, n);
                        if (x === n - 1n) {
                            continueLoop = true;
                            break;
                        }
                    }
                    
                    if (continueLoop) continue;
                    return false;
                }
                
                return true;
            }
            
            static generatePrime(bitLength) {
                while (true) {
                    const candidate = this.generateRandomBigInt(bitLength);
                    if (candidate % 2n === 0n) continue;
                    if (this.isProbablyPrime(candidate)) {
                        return candidate;
                    }
                }
            }
        }

        // Paillier Cryptosystem - Partially Homomorphic Encryption
        class PaillierCryptosystem {
            constructor(bitLength = 256) {
                this.bitLength = bitLength;
                this.publicKey = null;
                this.privateKey = null;
            }
            
            generateKeyPair() {
                // Generate two large primes
                const halfBitLength = this.bitLength / 2;
                let p, q, n, lambda, mu;
                
                do {
                    p = BigIntUtils.generatePrime(halfBitLength);
                    q = BigIntUtils.generatePrime(halfBitLength);
                    
                    // Ensure p and q are distinct
                    if (p === q) continue;
                    
                    n = p * q;
                    lambda = BigIntUtils.lcm(p - 1n, q - 1n);
                    
                    // Check if n and lambda are coprime
                    const g = n + 1n; // Standard choice for g
                    const x = BigIntUtils.modPow(g, lambda, n * n);
                    const l = (x - 1n) / n;
                    
                    mu = BigIntUtils.modInverse(l, n);
                } while (BigIntUtils.gcd(n, lambda) !== 1n);
                
                this.publicKey = { n, g: n + 1n };
                this.privateKey = { lambda, mu, n };
                
                return { publicKey: this.publicKey, privateKey: this.privateKey };
            }
            
            encrypt(m, publicKey = null) {
                const pk = publicKey || this.publicKey;
                if (!pk) throw new Error("Public key not available");
                
                const n = pk.n;
                const n2 = n * n;
                
                // Ensure message is in the valid range
                if (m < 0n || m >= n) {
                    throw new Error("Message out of range");
                }
                
                // Select random r where 1 <= r < n and gcd(r, n) = 1
                let r;
                do {
                    r = BigIntUtils.generateRandomBigInt(this.bitLength) % n;
                } while (r === 0n || BigIntUtils.gcd(r, n) !== 1n);
                
                // Compute ciphertext: c = g^m * r^n mod n^2
                const g_m = BigIntUtils.modPow(pk.g, m, n2);
                const r_n = BigIntUtils.modPow(r, n, n2);
                const c = (g_m * r_n) % n2;
                
                return c;
            }
            
            decrypt(c, privateKey = null) {
                const sk = privateKey || this.privateKey;
                if (!sk) throw new Error("Private key not available");
                
                const n = sk.n;
                const n2 = n * n;
                
                // Check if ciphertext is in the valid range
                if (c <= 0n || c >= n2) {
                    throw new Error("Ciphertext out of range");
                }
                
                // Compute message: m = L(c^lambda mod n^2) * mu mod n
                const c_lambda = BigIntUtils.modPow(c, sk.lambda, n2);
                const l = (c_lambda - 1n) / n;
                const m = (l * sk.mu) % n;
                
                return m;
            }
            
            // Homomorphic addition of two ciphertexts
            add(c1, c2, publicKey = null) {
                const pk = publicKey || this.publicKey;
                if (!pk) throw new Error("Public key not available");
                
                const n = pk.n;
                const n2 = n * n;
                
                return (c1 * c2) % n2;
            }
            
            // Homomorphic addition of a ciphertext and a plaintext
            addPlaintext(c, m, publicKey = null) {
                const pk = publicKey || this.publicKey;
                if (!pk) throw new Error("Public key not available");
                
                const n = pk.n;
                const n2 = n * n;
                
                const g_m = BigIntUtils.modPow(pk.g, m, n2);
                return (c * g_m) % n2;
            }
            
            // Homomorphic multiplication of a ciphertext by a plaintext scalar
            multiplyPlaintext(c, m, publicKey = null) {
                const pk = publicKey || this.publicKey;
                if (!pk) throw new Error("Public key not available");
                
                const n = pk.n;
                const n2 = n * n;
                
                return BigIntUtils.modPow(c, m, n2);
            }
            
            // Utility function to calculate least common multiple
            static lcm(a, b) {
                return (a * b) / BigIntUtils.gcd(a, b);
            }
        }

        // Data encoding and decoding utilities
        class DataEncoder {
            static encodeText(text, maxValue) {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(text);
                const numbers = [];
                
                // Convert bytes to numbers in the valid range
                for (let i = 0; i < bytes.length; i++) {
                    numbers.push(BigInt(bytes[i]) % maxValue);
                }
                
                return numbers;
            }
            
            static decodeText(numbers) {
                const bytes = new Uint8Array(numbers.length);
                
                for (let i = 0; i < numbers.length; i++) {
                    bytes[i] = Number(numbers[i]);
                }
                
                const decoder = new TextDecoder();
                return decoder.decode(bytes);
            }
            
            static encodeNumbers(numberString, maxValue) {
                const numbers = numberString.split(',').map(num => {
                    const trimmed = num.trim();
                    if (!trimmed) return null;
                    let value = BigInt(trimmed);
                    
                    // Ensure the number is in the valid range
                    if (value < 0n) value = 0n;
                    if (value >= maxValue) value = maxValue - 1n;
                    
                    return value;
                }).filter(num => num !== null);
                
                return numbers;
            }
            
            static decodeNumbers(numbers) {
                return numbers.map(num => num.toString()).join(', ');
            }
        }

        // Homomorphic Encryption UI Controller
        class HomomorphicEncryptionUI {
            constructor() {
                this.cryptoSystem = new PaillierCryptosystem(256);
                this.encryptedValues = [];
                this.publicKey = null;
                this.privateKey = null;
                this.initializeEventListeners();
            }
            
            initializeEventListeners() {
                document.getElementById('generateKeys').addEventListener('click', () => this.generateKeys());
                document.getElementById('encryptBtn').addEventListener('click', () => this.encryptData());
                document.getElementById('decryptBtn').addEventListener('click', () => this.decryptData());
                document.getElementById('computeBtn').addEventListener('click', () => this.performOperation());
                document.getElementById('runTests').addEventListener('click', () => this.runComprehensiveTests());
            }
            
            generateKeys() {
                this.setStatus('processing', 'Generating keys...');
                
                setTimeout(() => {
                    try {
                        const keyPair = this.cryptoSystem.generateKeyPair();
                        this.publicKey = keyPair.publicKey;
                        this.privateKey = keyPair.privateKey;
                        
                        document.getElementById('publicKey').textContent = 
                            `n: ${this.publicKey.n.toString()}\ng: ${this.publicKey.g.toString()}`;
                        
                        this.setStatus('ready', 'Key pair generated successfully');
                    } catch (error) {
                        this.setStatus('error', 'Key generation failed: ' + error.message);
                        console.error('Key generation error:', error);
                    }
                }, 100);
            }
            
            encryptData() {
                if (!this.publicKey) {
                    this.setStatus('error', 'Please generate a key pair first');
                    return;
                }
                
                this.setStatus('processing', 'Encrypting data...');
                this.showLoading('encrypt');
                
                setTimeout(() => {
                    try {
                        const inputData = document.getElementById('inputData').value;
                        const dataType = document.getElementById('dataType').value;
                        
                        let numbers;
                        if (dataType === 'text') {
                            numbers = DataEncoder.encodeText(inputData, this.publicKey.n);
                        } else {
                            numbers = DataEncoder.encodeNumbers(inputData, this.publicKey.n);
                        }
                        
                        this.encryptedValues = numbers.map(num => 
                            this.cryptoSystem.encrypt(num, this.publicKey)
                        );
                        
                        document.getElementById('encryptedData').textContent = 
                            this.encryptedValues.map(val => val.toString()).join('\n');
                        
                        this.setStatus('ready', `Encrypted ${numbers.length} values successfully`);
                        
                        if (document.getElementById('autoTest').checked) {
                            this.runBasicTests();
                        }
                    } catch (error) {
                        this.setStatus('error', 'Encryption failed: ' + error.message);
                        console.error('Encryption error:', error);
                    } finally {
                        this.hideLoading('encrypt');
                    }
                }, 100);
            }
            
            decryptData() {
                if (!this.privateKey) {
                    this.setStatus('error', 'Please generate a key pair first');
                    return;
                }
                
                if (this.encryptedValues.length === 0) {
                    this.setStatus('error', 'No encrypted data to decrypt');
                    return;
                }
                
                this.setStatus('processing', 'Decrypting data...');
                this.showLoading('decrypt');
                
                setTimeout(() => {
                    try {
                        const decryptedValues = this.encryptedValues.map(val => 
                            this.cryptoSystem.decrypt(val, this.privateKey)
                        );
                        
                        const dataType = document.getElementById('dataType').value;
                        let result;
                        
                        if (dataType === 'text') {
                            result = DataEncoder.decodeText(decryptedValues);
                        } else {
                            result = DataEncoder.decodeNumbers(decryptedValues);
                        }
                        
                        document.getElementById('outputData').textContent = result;
                        this.setStatus('ready', 'Decryption successful');
                    } catch (error) {
                        this.setStatus('error', 'Decryption failed: ' + error.message);
                        console.error('Decryption error:', error);
                    } finally {
                        this.hideLoading('decrypt');
                    document.getElementById('outputData').textContent = result || '';
                    document.getElementById('decryptedResult').textContent = result || '';
                    }
                }, 100);
            }
            
            performOperation() {
                if (!this.publicKey || this.encryptedValues.length === 0) {
                    this.setStatus('error', 'Please generate keys and encrypt data first');
                    return;
                }
                
                this.setStatus('processing', 'Performing operation...');
                
                setTimeout(() => {
                    try {
                        const operation = document.getElementById('operation').value;
                        const operand = BigInt(document.getElementById('operand').value);
                        const results = [];
                        
                        if (operation === 'add') {
                            // Homomorphic addition: E(a) + b = E(a + b)
                            for (const encryptedValue of this.encryptedValues) {
                                const result = this.cryptoSystem.addPlaintext(encryptedValue, operand, this.publicKey);
                                results.push(result);
                            }
                        } else if (operation === 'multiply') {
                            // Homomorphic multiplication: E(a) * b = E(a * b)
                            for (const encryptedValue of this.encryptedValues) {
                                const result = this.cryptoSystem.multiplyPlaintext(encryptedValue, operand, this.publicKey);
                                results.push(result);
                            }
                        } else if (operation === 'add_encrypted' && this.encryptedValues.length >= 2) {
                            // Homomorphic addition of two encrypted values: E(a) + E(b) = E(a + b)
                            results.push(this.cryptoSystem.add(
                                this.encryptedValues[0], 
                                this.encryptedValues[1], 
                                this.publicKey
                            ));
                        }
                        
                        document.getElementById('operationResult').textContent = 
                            results.map(val => val.toString()).join('\n');
                        
                        // Decrypt the results to verify the operation worked correctly
                        if (this.privateKey) {
                            const decryptedResults = results.map(val => 
                                this.cryptoSystem.decrypt(val, this.privateKey)
                            );
                            
                            const dataType = document.getElementById('dataType').value;
                            let decryptedText;
                            
                            if (dataType === 'text') {
                                decryptedText = DataEncoder.decodeText(decryptedResults);
                            } else {
                                decryptedText = DataEncoder.decodeNumbers(decryptedResults);
                            }
                            
                            document.getElementById('decryptedResult').textContent = decryptedText;
                        }
                        
                        this.setStatus('ready', 'Operation completed successfully');
                    } catch (error) {
                        this.setStatus('error', 'Operation failed: ' + error.message);
                        console.error('Operation error:', error);
                    }
                }, 100);
            }
            
            runBasicTests() {
                this.setTestStatus('processing', 'Running basic tests...');
                
                setTimeout(() => {
                    try {
                        if (!this.privateKey || this.encryptedValues.length === 0) {
                            this.setTestStatus('ready', 'Need keys and encrypted data to run tests');
                            return;
                        }
                        
                        const testResults = [];
                        
                        // Test 1: Decryption of encrypted values
                        const decryptedValues = this.encryptedValues.map(val => 
                            this.cryptoSystem.decrypt(val, this.privateKey)
                        );
                        
                        testResults.push({
                            name: "Decryption Test",
                            status: "PASS",
                            message: "All values decrypted successfully",
                            details: `Decrypted ${decryptedValues.length} values`
                        });
                        
                        // Test 2: Homomorphic addition test
                        if (this.encryptedValues.length >= 1) {
                            const original = decryptedValues[0];
                            const operand = 5n;
                            const encryptedResult = this.cryptoSystem.addPlaintext(
                                this.encryptedValues[0], operand, this.publicKey
                            );
                            const decryptedResult = this.cryptoSystem.decrypt(encryptedResult, this.privateKey);
                            const expected = original + operand;
                            
                            testResults.push({
                                name: "Homomorphic Addition Test",
                                status: decryptedResult === expected ? "PASS" : "FAIL",
                                message: `E(${original}) + ${operand} = E(${decryptedResult})`,
                                details: `Expected: ${expected}, Got: ${decryptedResult}`
                            });
                        }
                        
                        // Test 3: Homomorphic multiplication test
                        if (this.encryptedValues.length >= 1) {
                            const original = decryptedValues[0];
                            const operand = 3n;
                            const encryptedResult = this.cryptoSystem.multiplyPlaintext(
                                this.encryptedValues[0], operand, this.publicKey
                            );
                            const decryptedResult = this.cryptoSystem.decrypt(encryptedResult, this.privateKey);
                            const expected = original * operand;
                            
                            testResults.push({
                                name: "Homomorphic Multiplication Test",
                                status: decryptedResult === expected ? "PASS" : "FAIL",
                                message: `E(${original}) * ${operand} = E(${decryptedResult})`,
                                details: `Expected: ${expected}, Got: ${decryptedResult}`
                            });
                        }
                        
                        this.displayTestResults(testResults);
                        this.setTestStatus('ready', 'Basic tests completed');
                    } catch (error) {
                        this.setTestStatus('error', 'Tests failed: ' + error.message);
                    }
                }, 100);
            }
            
            runComprehensiveTests() {
                this.setTestStatus('processing', 'Running comprehensive tests...');
                
                setTimeout(() => {
                    try {
                        const testResults = [];
                        
                        // Generate a temporary key pair for testing
                        const testCrypto = new PaillierCryptosystem(128);
                        const testKeys = testCrypto.generateKeyPair();
                        
                        // Test 1: Basic encryption/decryption
                        const testValue = 42n;
                        const encrypted = testCrypto.encrypt(testValue, testKeys.publicKey);
                        const decrypted = testCrypto.decrypt(encrypted, testKeys.privateKey);
                        
                        testResults.push({
                            name: "Basic Encryption/Decryption",
                            status: decrypted === testValue ? "PASS" : "FAIL",
                            message: `E(D(E(${testValue}))) = ${decrypted}`,
                            details: `Expected: ${testValue}, Got: ${decrypted}`
                        });
                        
                        // Test 2: Homomorphic addition
                        const a = 15n;
                        const b = 27n;
                        const encA = testCrypto.encrypt(a, testKeys.publicKey);
                        const encB = testCrypto.encrypt(b, testKeys.publicKey);
                        
                        // E(a) + E(b) = E(a + b)
                        const encSum = testCrypto.add(encA, encB, testKeys.publicKey);
                        const decSum = testCrypto.decrypt(encSum, testKeys.privateKey);
                        
                        testResults.push({
                            name: "Encrypted Addition",
                            status: decSum === a + b ? "PASS" : "FAIL",
                            message: `E(${a}) + E(${b}) = E(${decSum})`,
                            details: `Expected: ${a + b}, Got: ${decSum}`
                        });
                        
                        // Test 3: Homomorphic addition with plaintext
                        const c = 33n;
                        const encC = testCrypto.encrypt(c, testKeys.publicKey);
                        
                        // E(a) + b = E(a + b)
                        const encSumPlain = testCrypto.addPlaintext(encC, b, testKeys.publicKey);
                        const decSumPlain = testCrypto.decrypt(encSumPlain, testKeys.privateKey);
                        
                        testResults.push({
                            name: "Plaintext Addition",
                            status: decSumPlain === c + b ? "PASS" : "FAIL",
                            message: `E(${c}) + ${b} = E(${decSumPlain})`,
                            details: `Expected: ${c + b}, Got: ${decSumPlain}`
                        });
                        
                        // Test 4: Homomorphic multiplication with plaintext
                        const d = 7n;
                        const e = 6n;
                        const encD = testCrypto.encrypt(d, testKeys.publicKey);
                        
                        // E(a) * b = E(a * b)
                        const encProduct = testCrypto.multiplyPlaintext(encD, e, testKeys.publicKey);
                        const decProduct = testCrypto.decrypt(encProduct, testKeys.privateKey);
                        
                        testResults.push({
                            name: "Plaintext Multiplication",
                            status: decProduct === d * e ? "PASS" : "FAIL",
                            message: `E(${d}) * ${e} = E(${decProduct})`,
                            details: `Expected: ${d * e}, Got: ${decProduct}`
                        });
                        
                        // Test 5: Zero knowledge property (different encryption of same value)
                        const enc1 = testCrypto.encrypt(testValue, testKeys.publicKey);
                        const enc2 = testCrypto.encrypt(testValue, testKeys.publicKey);
                        
                        testResults.push({
                            name: "Zero-Knowledge Property",
                            status: enc1 !== enc2 ? "PASS" : "FAIL",
                            message: "E(m) â‰  E(m) (different randomizations)",
                            details: `Different encryptions: ${enc1 !== enc2}`
                        });
                        
                        this.displayTestResults(testResults);
                        this.setTestStatus('ready', 'Comprehensive tests completed');
                    } catch (error) {
                        this.setTestStatus('error', 'Tests failed: ' + error.message);
                    }
                }, 100);
            }
            
            displayTestResults(results) {
                const testResultsDiv = document.getElementById('testResults');
                testResultsDiv.innerHTML = '';
                
                results.forEach(test => {
                    const testDiv = document.createElement('div');
                    testDiv.className = `test-result ${test.status === 'PASS' ? 'test-pass' : 'test-fail'}`;
                    
                    testDiv.innerHTML = `
                        <strong>${test.name}</strong>: ${test.status}
                        <div>${test.message}</div>
                        <div style="font-size: 0.8em; color: #94a3b8; margin-top: 0.5rem;">${test.details}</div>
                    `;
                    
                    testResultsDiv.appendChild(testDiv);
                });
            }
            
            setStatus(type, message) {
                const indicator = document.getElementById('statusIndicator');
                if (indicator) {
                    indicator.className = `status-${type}`;
                    indicator.textContent = message;
                }
            }
            
            setTestStatus(type, message) {
                const indicator = document.getElementById('testStatus');
                if (indicator) {
                    indicator.className = `status-${type}`;
                    indicator.textContent = message;
                }
            }
            
            showLoading(button) {
                const loadingElement = document.getElementById(`${button}Loading`);
                if (loadingElement) {
                    loadingElement.style.display = 'inline-block';
                }
                const buttonElement = document.getElementById(`${button}Btn`);
                if (buttonElement) {
                    buttonElement.disabled = true;
                }
            }
            
            hideLoading(button) {
                const loadingElement = document.getElementById(`${button}Loading`);
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
                const buttonElement = document.getElementById(`${button}Btn`);
                if (buttonElement) {
                    buttonElement.disabled = false;
                }
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new HomomorphicEncryptionUI();
        });
    </script>
</body>
</html>
