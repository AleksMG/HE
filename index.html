<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–î–≤—É—Ö—ç—Ç–∞–ø–Ω–æ–µ S-Box —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background: #0d1117;
            color: #c9d1d9;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        textarea, input, select {
            width: 100%;
            background: #161b22;
            color: #c9d1d9;
            border: 1px solid #30363d;
            padding: 8px;
            margin: 5px 0;
        }
        button {
            background: #238636;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #2ea043;
        }
        .output {
            background: #161b22;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .row {
            display: flex;
            margin: 10px 0;
            gap: 20px;
        }
        .col {
            flex: 1;
        }
        .section {
            border: 1px solid #30363d;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîí –î–≤—É—Ö—ç—Ç–∞–ø–Ω–æ–µ S-Box —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h1>
        
        <div class="section">
            <h3>Key Configuration:</h3>
            <input type="password" id="keyInput" placeholder="Enter encryption key" value="my-secret-key">
            <button onclick="generateSBoxes()">Generate S-Boxes from Key</button>
            <div class="output" id="status">S-Boxes not generated yet</div>
        </div>

        <div class="row">
            <div class="col">
                <div class="section">
                    <h3>Encryption:</h3>
                    <textarea id="encryptInput" rows="4" placeholder="Enter text to encrypt">Hello, World!</textarea>
                    <button onclick="encryptData()">Encrypt</button>
                    <div class="output" id="encryptOutput">Encrypted output will appear here</div>
                </div>
            </div>
            
            <div class="col">
                <div class="section">
                    <h3>Decryption:</h3>
                    <textarea id="decryptInput" rows="4" placeholder="Paste encrypted hex here"></textarea>
                    <button onclick="decryptData()">Decrypt</button>
                    <div class="output" id="decryptOutput">Decrypted output will appear here</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let sbox1 = null; // –ü–µ—Ä–≤—ã–π S-Box: 256 –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ ‚Üí 256 –∏–≥—Ä—É—à–µ–∫
        let sbox2 = null; // –í—Ç–æ—Ä–æ–π S-Box: 256 –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ ‚Üí 256 –∏–≥—Ä—É—à–µ–∫ (—Ç–µ –∂–µ –∏–≥—Ä—É—à–∫–∏, –Ω–æ –≤ –¥—Ä—É–≥–æ–º –ø–æ—Ä—è–¥–∫–µ)
        let inverseMap = new Map(); // –î–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: –∏–≥—Ä—É—à–∫–∞ ‚Üí –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –≤ sbox1

        function cryptoShuffle(array, keyBytes) {
            const result = [...array];
            for (let i = result.length - 1; i > 0; i--) {
                const keyIndex = i % keyBytes.length;
                const j = keyBytes[keyIndex] % (i + 1);
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        async function generateSBoxes() {
            const key = document.getElementById('keyInput').value;
            if (!key) {
                alert('Please enter a key');
                return;
            }

            const statusElement = document.getElementById('status');
            statusElement.textContent = 'Generating S-Boxes...';

            try {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(key);
                
                const cryptoKey = await crypto.subtle.importKey(
                    'raw', keyData, { name: 'HMAC', hash: 'SHA-512' }, false, ['sign']
                );

                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º seed –¥–ª—è –æ–±–æ–∏—Ö S-Box
                const seed1 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('sbox1'));
                const seed2 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('sbox2'));
                
                const seedBytes1 = new Uint8Array(seed1);
                const seedBytes2 = new Uint8Array(seed2);

                // –°–æ–∑–¥–∞–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∏–≥—Ä—É—à–∫–∏ (–æ–º–æ—Ñ–æ–Ω—ã) 0-65535
                const allToys = Array.from({length: 65536}, (_, i) => i);
                
                // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∏–≥—Ä—É—à–∫–∏ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ S-Box
                const shuffledToys1 = cryptoShuffle([...allToys], Array.from(seedBytes1));
                
                // –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–≤—ã–π S-Box
                sbox1 = [];
                let toyIndex = 0;
                
                for (let container = 0; container < 256; container++) {
                    sbox1[container] = [];
                    for (let i = 0; i < 256; i++) {
                        sbox1[container].push(shuffledToys1[toyIndex++]);
                    }
                }

                // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∏–≥—Ä—É—à–∫–∏ –¥–ª—è –≤—Ç–æ—Ä–æ–≥–æ S-Box
                const shuffledToys2 = cryptoShuffle([...allToys], Array.from(seedBytes2));
                
                // –°–æ–∑–¥–∞–µ–º –≤—Ç–æ—Ä–æ–π S-Box
                sbox2 = [];
                toyIndex = 0;
                
                for (let container = 0; container < 256; container++) {
                    sbox2[container] = [];
                    for (let i = 0; i < 256; i++) {
                        sbox2[container].push(shuffledToys2[toyIndex++]);
                    }
                }

                // –°–æ–∑–¥–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                inverseMap.clear();
                for (let container = 0; container < 256; container++) {
                    for (let i = 0; i < 256; i++) {
                        inverseMap.set(sbox1[container][i], container);
                    }
                }

                statusElement.textContent = 'S-Boxes generated successfully!';

            } catch (error) {
                statusElement.textContent = 'Error: ' + error.message;
            }
        }

        function encryptData() {
            if (!sbox1 || !sbox2) {
                alert('Please generate S-Boxes first');
                return;
            }

            const inputText = document.getElementById('encryptInput').value;
            if (!inputText) {
                alert('Please enter text to encrypt');
                return;
            }

            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(inputText);
                let encryptedData = [];

                for (let i = 0; i < data.length; i++) {
                    const byte = data[i];
                    
                    // –ü–µ—Ä–≤—ã–π —ç—Ç–∞–ø: –≤—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é –∏–≥—Ä—É—à–∫—É –∏–∑ –ø–µ—Ä–≤–æ–≥–æ S-Box
                    const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0] % 256;
                    const toy = sbox1[byte][randomIndex];
                    
                    // –í—Ç–æ—Ä–æ–π —ç—Ç–∞–ø: –∏—â–µ–º —ç—Ç—É –∏–≥—Ä—É—à–∫—É –≤–æ –≤—Ç–æ—Ä–æ–º S-Box
                    let foundContainer = null;
                    
                    for (let container = 0; container < 256; container++) {
                        if (sbox2[container].includes(toy)) {
                            foundContainer = container;
                            break;
                        }
                    }
                    
                    if (foundContainer === null) {
                        throw new Error('Toy not found in second S-Box');
                    }
                    
                    encryptedData.push(foundContainer);
                }

                const hexOutput = encryptedData.map(byte => byte.toString(16).padStart(2, '0')).join(' ');
                
                document.getElementById('encryptOutput').textContent = hexOutput;
                document.getElementById('decryptInput').value = hexOutput;

            } catch (error) {
                document.getElementById('encryptOutput').textContent = 'Encryption error: ' + error.message;
            }
        }

        function decryptData() {
            if (!sbox2 || inverseMap.size === 0) {
                alert('Please generate S-Boxes first');
                return;
            }

            const hexText = document.getElementById('decryptInput').value.trim();
            if (!hexText) {
                alert('Please enter encrypted hex data');
                return;
            }

            try {
                const hexValues = hexText.split(/\s+/).filter(x => x);
                const encryptedBytes = [];
                
                for (const hexValue of hexValues) {
                    const byte = parseInt(hexValue, 16);
                    if (!isNaN(byte) && byte >= 0 && byte <= 255) {
                        encryptedBytes.push(byte);
                    }
                }

                const decoder = new TextDecoder();
                const decryptedData = new Uint8Array(encryptedBytes.length);

                for (let i = 0; i < encryptedBytes.length; i++) {
                    const container = encryptedBytes[i];
                    
                    // –î–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –Ω–∞–º –Ω—É–∂–Ω–æ –∑–Ω–∞—Ç—å, –∫–∞–∫–∞—è –∏–≥—Ä—É—à–∫–∞ –±—ã–ª–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞
                    // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —ç—Ç–æ –¥–æ–ª–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏
                    // –ó–¥–µ—Å—å –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—É—é –∏–≥—Ä—É—à–∫—É –∏–∑ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
                    const toy = sbox2[container][0];
                    
                    // –ù–∞—Ö–æ–¥–∏–º –∏—Å—Ö–æ–¥–Ω—ã–π –±–∞–π—Ç —Å –ø–æ–º–æ—â—å—é inverseMap
                    const originalByte = inverseMap.get(toy);
                    
                    if (originalByte === undefined) {
                        throw new Error('Toy not found in inverse map');
                    }
                    
                    decryptedData[i] = originalByte;
                }

                const decryptedText = decoder.decode(decryptedData);
                document.getElementById('decryptOutput').textContent = decryptedText;

            } catch (error) {
                document.getElementById('decryptOutput').textContent = 'Decryption error: ' + error.message;
            }
        }
    </script>
</body>
</html>
