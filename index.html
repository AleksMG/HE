<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeoCrypt | Advanced Omophonic Encryption</title>
    <style>
        :root {
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --secondary: #94a3b8;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --background: #f8fafc;
            --surface: #ffffff;
            --text: #1e293b;
            --text-light: #64748b;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
        }

        body {
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: var(--surface);
            color: var(--text);
            padding: 2rem;
            text-align: center;
            border-radius: 16px;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--text-light);
            font-weight: 400;
        }

        .grid-system {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 24px;
        }

        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.75rem;
            margin-bottom: 24px;
            box-shadow: var(--shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.1);
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }

        .panel-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--primary);
        }

        .btn {
            padding: 1rem 1.5rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            background: var(--primary);
            color: white;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--background);
            border-color: var(--primary-light);
        }

        .form-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text);
            font-size: 0.95rem;
        }

        input, select, textarea {
            width: 100%;
            padding: 0.875rem;
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 0.95rem;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .result-area {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            min-height: 120px;
            max-height: 320px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .test-result {
            padding: 1rem;
            margin: 0.75rem 0;
            border-radius: 8px;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .test-pass {
            background: rgba(16, 185, 129, 0.08);
            border-left: 4px solid var(--success);
            color: var(--text);
        }

        .test-fail {
            background: rgba(239, 68, 68, 0.08);
            border-left: 4px solid var(--danger);
            color: var(--text);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.75rem;
        }

        .status-active { background: var(--success); }
        .status-warning { background: var(--warning); }
        .status-danger { background: var(--danger); }

        .operation-flow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 1.5rem 0;
            padding: 1.5rem;
            background: var(--background);
            border-radius: 12px;
            border: 2px solid var(--border);
        }

        .operation-step {
            text-align: center;
            padding: 1rem;
            flex: 1;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .metric-box {
            padding: 1.25rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--surface);
            text-align: center;
        }

        .metric-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--primary);
            margin: 0.5rem 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-light), var(--primary));
            transition: width 0.3s ease;
        }

        .icon {
            font-size: 1.5rem;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîê NeoCrypt</h1>
            <p class="subtitle">Advanced Omophonic Encryption with HMAC-SHA512 & Galois Field Operations</p>
        </header>

        <div class="grid-system">
            <!-- Left Panel -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <div class="icon">‚öôÔ∏è</div>
                        <h3 class="panel-title">SYSTEM CONFIGURATION</h3>
                    </div>
                    
                    <div class="form-group">
                        <label>Master Password:</label>
                        <input type="password" id="crypto-key" value="secure-master-password-256bit" placeholder="Enter strong password">
                    </div>

                    <div class="form-group">
                        <label>Key Derivation Iterations:</label>
                        <input type="number" id="key-iterations" value="100000" min="10000" max="1000000">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 70%;"></div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Galois Field Prime:</label>
                        <input type="number" id="galois-prime" value="65521" min="32768" max="65535">
                    </div>

                    <button class="btn" onclick="initializeSystem()">
                        <span class="icon">üöÄ</span>
                        INITIALIZE CRYPTO SYSTEM
                    </button>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <div class="icon">üß™</div>
                        <h3 class="panel-title">SYSTEM VALIDATION</h3>
                    </div>
                    
                    <button class="btn" onclick="runAllTests()">
                        <span class="icon">‚úÖ</span>
                        RUN COMPREHENSIVE TESTS
                    </button>

                    <button class="btn btn-secondary" onclick="testReversibility()">
                        <span class="icon">üîÑ</span>
                        TEST REVERSIBILITY
                    </button>

                    <button class="btn btn-secondary" onclick="testHomomorphicProperties()">
                        <span class="icon">üßÆ</span>
                        TEST HOMOMORPHISM
                    </button>

                    <button class="btn btn-secondary" onclick="testCryptographicSecurity()">
                        <span class="icon">üîí</span>
                        TEST SECURITY
                    </button>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <div class="icon">üìä</div>
                        <h3 class="panel-title">SYSTEM STATUS</h3>
                    </div>
                    
                    <div class="result-area">
                        <div><span class="status-indicator status-danger"></span>S-Box Integrity: <span id="status-sbox">NOT INITIALIZED</span></div>
                        <div><span class="status-indicator status-danger"></span>Crypto Core: <span id="status-crypto">OFFLINE</span></div>
                        <div><span class="status-indicator status-danger"></span>Homomorphic Engine: <span id="status-homo">OFFLINE</span></div>
                        <div><span class="status-indicator status-danger"></span>Validation Suite: <span id="status-test">PENDING</span></div>
                    </div>
                </div>
            </div>

            <!-- Right Panel -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <div class="icon">üî¢</div>
                        <h3 class="panel-title">CRYPTO OPERATIONS</h3>
                    </div>
                    
                    <div class="form-group">
                        <label>Value A (0-255):</label>
                        <input type="number" id="input-a" value="42" min="0" max="255">
                    </div>

                    <div class="form-group">
                        <label>Value B (0-255):</label>
                        <input type="number" id="input-b" value="17" min="0" max="255">
                    </div>

                    <div class="operation-flow">
                        <div class="operation-step">A ‚Üí Encrypt ‚Üí</div>
                        <div class="operation-step" style="font-size: 1.5rem; color: var(--primary);">+</div>
                        <div class="operation-step">B ‚Üí Encrypt ‚Üí</div>
                        <div class="operation-step" style="font-size: 1.5rem; color: var(--primary);">=</div>
                        <div class="operation-step">‚Üê Decrypt ‚Üê</div>
                    </div>

                    <button class="btn" onclick="performHomomorphicAddition()">
                        <span class="icon">‚ûï</span>
                        EXECUTE HOMOMORPHIC ADDITION
                    </button>

                    <div class="result-area" id="operation-result">
                        <div style="color: var(--text-light); text-align: center; padding: 2rem;">
                            üîí Operation results will appear here after execution
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <div class="icon">üìà</div>
                        <h3 class="panel-title">VALIDATION RESULTS</h3>
                    </div>
                    
                    <div class="result-area" id="test-results">
                        <div class="test-result test-fail">
                            <span class="icon">‚ùå</span>
                            <div>Reversibility: NOT TESTED</div>
                        </div>
                        <div class="test-result test-fail">
                            <span class="icon">‚ùå</span>
                            <div>Homomorphism: NOT TESTED</div>
                        </div>
                        <div class="test-result test-fail">
                            <span class="icon">‚ùå</span>
                            <div>Security: NOT TESTED</div>
                        </div>
                        <div class="test-result test-fail">
                            <span class="icon">‚ùå</span>
                            <div>Performance: NOT TESTED</div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <div class="icon">üìä</div>
                        <h3 class="panel-title">SYSTEM METRICS</h3>
                    </div>
                    
                    <div class="metric-grid">
                        <div class="metric-box">
                            <div>Entropy Quality</div>
                            <div class="metric-value" id="metric-entropy">0.00</div>
                            <div>bits/byte</div>
                        </div>
                        <div class="metric-box">
                            <div>Avalanche Effect</div>
                            <div class="metric-value" id="metric-avalanche">0%</div>
                            <div>bit diffusion</div>
                        </div>
                        <div class="metric-box">
                            <div>Operations Speed</div>
                            <div class="metric-value" id="metric-speed">0</div>
                            <div>ops/second</div>
                        </div>
                        <div class="metric-box">
                            <div>System Integrity</div>
                            <div class="metric-value" id="metric-errors">0</div>
                            <div>errors</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =============================================================================
        // GALOIS FIELD OPERATIONS
        // =============================================================================

        class GaloisField {
            constructor(prime) {
                this.prime = prime;
                this.inverseCache = new Map();
            }

            add(a, b) {
                return (a + b) % this.prime;
            }

            subtract(a, b) {
                return (a - b + this.prime) % this.prime;
            }

            multiply(a, b) {
                return Number((BigInt(a) * BigInt(b)) % BigInt(this.prime));
            }

            divide(a, b) {
                if (b === 0) throw new Error("Division by zero");
                const inv = this.inverse(b);
                return this.multiply(a, inv);
            }

            inverse(a) {
                if (this.inverseCache.has(a)) return this.inverseCache.get(a);
                
                // Extended Euclidean Algorithm
                let [old_r, r] = [a, this.prime];
                let [old_s, s] = [1, 0];
                let [old_t, t] = [0, 1];

                while (r !== 0) {
                    const quotient = Math.floor(old_r / r);
                    [old_r, r] = [r, old_r - quotient * r];
                    [old_s, s] = [s, old_s - quotient * s];
                    [old_t, t] = [t, old_t - quotient * t];
                }

                if (old_r !== 1) throw new Error("Element not invertible");
                let result = old_s;
                if (result < 0) result += this.prime;
                
                this.inverseCache.set(a, result);
                return result;
            }
        }

        // =============================================================================
        // PROFESSIONAL OMOPHONIC CRYPTO SYSTEM
        // =============================================================================

        class ProfessionalOmophonicCrypto {
            constructor() {
                this.initialized = false;
                this.sBox = new Map();
                this.inverseSBox = new Map();
                this.encryptionKey = null;
                this.hmacKey = null;
                this.galoisField = null;
                this.iv = null;
                
                this.testResults = {
                    reversibility: { passed: false, message: "Not tested" },
                    homomorphic: { passed: false, message: "Not tested" },
                    security: { passed: false, message: "Not tested" },
                    performance: { passed: false, message: "Not tested" }
                };
                
                this.metrics = {
                    entropy: 0,
                    avalanche: 0,
                    speed: 0,
                    errors: 0
                };
            }

            async initializeSystem(password, iterations = 100000, galoisPrime = 65521) {
                try {
                    console.log("üîß Initializing cryptographic system...");
                    
                    // Derive keys using HMAC-SHA512
                    await this.deriveKeys(password, iterations);
                    
                    // Initialize Galois Field
                    this.galoisField = new GaloisField(galoisPrime);
                    
                    // Generate S-Box using HMAC
                    await this.generateSBox();
                    
                    // Initialize IV
                    this.iv = crypto.getRandomValues(new Uint16Array(1))[0];
                    
                    // Run validation tests
                    await this.runInitialTests();
                    
                    this.initialized = true;
                    console.log("‚úÖ System initialized successfully");
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå Initialization failed:', error);
                    this.metrics.errors++;
                    return false;
                }
            }

            async deriveKeys(password, iterations) {
                const encoder = new TextEncoder();
                const passwordBuffer = encoder.encode(password);
                
                // Import password for key derivation
                const importedKey = await crypto.subtle.importKey(
                    'raw',
                    passwordBuffer,
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits']
                );
                
                // Derive 512 bits (256 for encryption, 256 for HMAC)
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: new TextEncoder().encode('NeoCrypt-Salt-256'),
                        iterations: iterations,
                        hash: 'SHA-512'
                    },
                    importedKey,
                    512
                );
                
                const derivedArray = new Uint8Array(derivedBits);
                this.encryptionKey = derivedArray.slice(0, 32); // 256 bits
                this.hmacKey = derivedArray.slice(32, 64); // 256 bits
            }

            async generateSBox() {
                this.sBox.clear();
                this.inverseSBox.clear();
                
                console.log("üîÑ Generating S-Box with HMAC-SHA512...");
                
                for (let byteValue = 0; byteValue < 256; byteValue++) {
                    const omophones = new Set();
                    
                    while (omophones.size < 256) {
                        const omophone = await this.generateOmophone(byteValue, omophones.size);
                        if (!this.inverseSBox.has(omophone)) {
                            omophones.add(omophone);
                            this.inverseSBox.set(omophone, byteValue);
                        }
                    }
                    
                    this.sBox.set(byteValue, Array.from(omophones));
                    
                    // Update progress every 16 bytes
                    if (byteValue % 16 === 0) {
                        const progress = (byteValue / 255) * 100;
                        console.log(`üìä S-Box progress: ${progress.toFixed(1)}%`);
                    }
                }
            }

            async generateOmophone(byteValue, index) {
                const hmacData = new TextEncoder().encode(`${byteValue}-${index}`);
                
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    this.hmacKey,
                    { name: 'HMAC', hash: 'SHA-512' },
                    false,
                    ['sign']
                );
                
                const signature = await crypto.subtle.sign('HMAC', cryptoKey, hmacData);
                const signatureArray = new Uint8Array(signature);
                
                // Convert to 16-bit omophone (0-65535)
                let omophone = 0;
                for (let i = 0; i < signatureArray.length - 1; i += 2) {
                    omophone = (omophone ^ (signatureArray[i] << 8 | signatureArray[i + 1])) & 0xFFFF;
                }
                
                return omophone;
            }

            async encryptByte(byteValue) {
                if (!this.initialized) throw new Error("System not initialized");
                if (byteValue < 0 || byteValue > 255) throw new Error("Byte value out of range");
                
                const omophones = this.sBox.get(byteValue);
                const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0];
                return omophones[randomIndex];
            }

            async decryptOmophone(omophone) {
                if (!this.initialized) throw new Error("System not initialized");
                
                const result = this.inverseSBox.get(omophone);
                if (result === undefined) throw new Error("Invalid omophone");
                
                return result;
            }

            async homomorphicAdd(omoA, omoB) {
                return this.galoisField.add(omoA, omoB);
            }

            async homomorphicMultiply(omoA, omoB) {
                return this.galoisField.multiply(omoA, omoB);
            }

            // =============================================================================
            // VALIDATION AND TESTING
            // =============================================================================

            async runInitialTests() {
                this.testResults.reversibility = await this.testReversibility();
                this.testResults.homomorphic = await this.testHomomorphicProperties();
                this.testResults.security = await this.testSecurity();
                this.testResults.performance = await this.testPerformance();
                
                await this.calculateMetrics();
            }

            async testReversibility() {
                const testCases = 1000;
                let passed = 0;
                
                for (let i = 0; i < testCases; i++) {
                    try {
                        const testValue = Math.floor(Math.random() * 256);
                        const encrypted = await this.encryptByte(testValue);
                        const decrypted = await this.decryptOmophone(encrypted);
                        
                        if (decrypted === testValue) passed++;
                    } catch (error) {
                        console.error("Reversibility test error:", error);
                    }
                }
                
                return {
                    passed: passed === testCases,
                    message: `${passed}/${testCases} tests passed`
                };
            }

            async testHomomorphicProperties() {
                const testCases = 100;
                let passed = 0;
                
                for (let i = 0; i < testCases; i++) {
                    try {
                        const a = Math.floor(Math.random() * 100);
                        const b = Math.floor(Math.random() * 100);
                        
                        const encA = await this.encryptByte(a);
                        const encB = await this.encryptByte(b);
                        const encSum = await this.homomorphicAdd(encA, encB);
                        const decrypted = await this.decryptOmophone(encSum);
                        
                        if (decrypted === (a + b) % 256) passed++;
                    } catch (error) {
                        console.error("Homomorphism test error:", error);
                    }
                }
                
                return {
                    passed: passed === testCases,
                    message: `${passed}/${testCases} tests passed`
                };
            }

            async testSecurity() {
                const avalanche = await this.testAvalancheEffect();
                const entropy = await this.testEntropy();
                
                return {
                    passed: avalanche && entropy,
                    message: `Avalanche: ${avalanche ? '‚úì' : '‚úó'}, Entropy: ${entropy ? '‚úì' : '‚úó'}`
                };
            }

            async testAvalancheEffect() {
                const testCases = 1000;
                let totalChange = 0;
                
                for (let i = 0; i < testCases; i++) {
                    const input = Math.floor(Math.random() * 256);
                    const input2 = (input + 1) % 256;
                    
                    const enc1 = await this.encryptByte(input);
                    const enc2 = await this.encryptByte(input2);
                    
                    const diff = enc1 ^ enc2;
                    let changedBits = 0;
                    for (let j = 0; j < 16; j++) {
                        if (diff & (1 << j)) changedBits++;
                    }
                    
                    totalChange += (changedBits / 16) * 100;
                }
                
                this.metrics.avalanche = totalChange / testCases;
                return this.metrics.avalanche > 45 && this.metrics.avalanche < 55;
            }

            async testEntropy() {
                const samples = 10000;
                const frequency = new Map();
                
                for (let i = 0; i < samples; i++) {
                    const value = Math.floor(Math.random() * 256);
                    const encrypted = await this.encryptByte(value);
                    frequency.set(encrypted, (frequency.get(encrypted) || 0) + 1);
                }
                
                let entropy = 0;
                const total = samples;
                
                for (const count of frequency.values()) {
                    const probability = count / total;
                    entropy -= probability * Math.log2(probability);
                }
                
                this.metrics.entropy = entropy;
                return entropy > 15;
            }

            async testPerformance() {
                const start = performance.now();
                const operations = 1000;
                
                for (let i = 0; i < operations; i++) {
                    await this.encryptByte(Math.floor(Math.random() * 256));
                }
                
                const duration = performance.now() - start;
                this.metrics.speed = Math.round(operations / (duration / 1000));
                return this.metrics.speed > 50;
            }

            async calculateMetrics() {
                this.metrics.entropy = Number(this.metrics.entropy.toFixed(2));
                this.metrics.avalanche = Number(this.metrics.avalanche.toFixed(1));
            }
        }

        // =============================================================================
        // UI MANAGEMENT
        // =============================================================================

        const cryptoSystem = new ProfessionalOmophonicCrypto();

        async function initializeSystem() {
            const password = document.getElementById('crypto-key').value;
            const iterations = parseInt(document.getElementById('key-iterations').value);
            const galoisPrime = parseInt(document.getElementById('galois-prime').value);
            
            updateStatus('sbox', 'warning', 'Generating S-Box...');
            updateStatus('crypto', 'warning', 'Deriving keys...');
            updateStatus('homo', 'warning', 'Initializing GF...');
            updateStatus('test', 'warning', 'Pending tests...');
            
            const success = await cryptoSystem.initializeSystem(password, iterations, galoisPrime);
            
            if (success) {
                updateStatus('sbox', 'active', 'Ready');
                updateStatus('crypto', 'active', 'Operational');
                updateStatus('homo', 'active', 'Active');
                updateStatus('test', 'active', 'Tests passed');
                
                updateTestResults();
                updateMetrics();
            } else {
                updateStatus('sbox', 'danger', 'Failed');
                updateStatus('crypto', 'danger', 'Failed');
                updateStatus('homo', 'danger', 'Failed');
                updateStatus('test', 'danger', 'Tests failed');
            }
        }

        async function performHomomorphicAddition() {
            try {
                const a = parseInt(document.getElementById('input-a').value);
                const b = parseInt(document.getElementById('input-b').value);
                
                if (a < 0 || a > 255 || b < 0 || b > 255) {
                    throw new Error("Values must be between 0-255");
                }
                
                const encA = await cryptoSystem.encryptByte(a);
                const encB = await cryptoSystem.encryptByte(b);
                const encSum = await cryptoSystem.homomorphicAdd(encA, encB);
                const result = await cryptoSystem.decryptOmophone(encSum);
                const expected = (a + b) % 256;
                
                document.getElementById('operation-result').innerHTML = `
                    <div><strong>A = ${a}</strong> ‚Üí Encrypted: <code>${encA}</code></div>
                    <div><strong>B = ${b}</strong> ‚Üí Encrypted: <code>${encB}</code></div>
                    <div><strong>Encrypted Sum:</strong> <code>${encSum}</code></div>
                    <div><strong>Result:</strong> ${result} (expected: ${expected})</div>
                    <div style="margin-top: 1rem; padding: 0.75rem; background: ${result === expected ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)'}; border-radius: 8px; border-left: 4px solid ${result === expected ? '#10b981' : '#ef4444'};">
                        ${result === expected ? '‚úÖ Operation successful' : '‚ùå Operation failed'}
                    </div>
                `;
                
            } catch (error) {
                document.getElementById('operation-result').innerHTML = `
                    <div style="color: #ef4444; padding: 1rem; background: rgba(239, 68, 68, 0.1); border-radius: 8px; border-left: 4px solid #ef4444;">
                        <strong>Error:</strong> ${error.message}
                    </div>
                `;
                cryptoSystem.metrics.errors++;
                updateMetrics();
            }
        }

        async function runAllTests() {
            updateStatus('test', 'warning', 'Running tests...');
            await cryptoSystem.runInitialTests();
            updateTestResults();
            updateMetrics();
            updateStatus('test', 'active', 'Tests completed');
        }

        async function testReversibility() {
            const result = await cryptoSystem.testReversibility();
            updateTestResult('reversibility', result);
        }

        async function testHomomorphicProperties() {
            const result = await cryptoSystem.testHomomorphicProperties();
            updateTestResult('homomorphic', result);
        }

        async function testCryptographicSecurity() {
            const result = await cryptoSystem.testSecurity();
            updateTestResult('security', result);
        }

        function updateTestResult(testName, result) {
            const tests = ['reversibility', 'homomorphic', 'security', 'performance'];
            const index = tests.indexOf(testName);
            const element = document.querySelector(`#test-results .test-result:nth-child(${index + 1})`);
            
            if (element) {
                element.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                element.innerHTML = `<span class="icon">${result.passed ? '‚úÖ' : '‚ùå'}</span><div>${testName}: ${result.message}</div>`;
            }
        }

        function updateTestResults() {
            updateTestResult('reversibility', cryptoSystem.testResults.reversibility);
            updateTestResult('homomorphic', cryptoSystem.testResults.homomorphic);
            updateTestResult('security', cryptoSystem.testResults.security);
            updateTestResult('performance', cryptoSystem.testResults.performance);
        }

        function updateMetrics() {
            document.getElementById('metric-entropy').textContent = cryptoSystem.metrics.entropy;
            document.getElementById('metric-avalanche').textContent = cryptoSystem.metrics.avalanche + '%';
            document.getElementById('metric-speed').textContent = cryptoSystem.metrics.speed.toLocaleString();
            document.getElementById('metric-errors').textContent = cryptoSystem.metrics.errors;
        }

        function updateStatus(element, status, text) {
            const indicator = document.getElementById(`status-${element}-indicator`);
            const textElement = document.getElementById(`status-${element}`);
            
            if (indicator && textElement) {
                indicator.className = `status-indicator status-${status}`;
                textElement.textContent = text;
            }
        }

        // Initialize UI
        window.addEventListener('load', () => {
            updateStatus('sbox', 'danger', 'Not initialized');
            updateStatus('crypto', 'danger', 'Offline');
            updateStatus('homo', 'danger', 'Offline');
            updateStatus('test', 'danger', 'Pending');
        });
    </script>
</body>
</html>
