<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeoCrypt | Professional Omophonic Encryption</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-light: #3b82f6;
            --primary-dark: #1d4ed8;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --background: #f8fafc;
            --surface: #ffffff;
            --text: #1e293b;
            --text-light: #64748b;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        body {
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: var(--surface);
            padding: 2rem;
            text-align: center;
            border-radius: 16px;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--text-light);
        }

        .grid-system {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 24px;
        }

        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 24px;
            box-shadow: var(--shadow);
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }

        .panel-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--primary);
        }

        .btn {
            padding: 1rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            background: var(--primary);
            color: white;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--background);
            border-color: var(--primary);
        }

        .form-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text);
        }

        input, select {
            width: 100%;
            padding: 0.875rem;
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
        }

        input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .result-area {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            min-height: 120px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .test-result {
            padding: 1rem;
            margin: 0.75rem 0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .test-pass {
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid var(--success);
        }

        .test-fail {
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid var(--danger);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0.5rem 0;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-active { background: var(--success); }
        .status-warning { background: var(--warning); }
        .status-danger { background: var(--danger); }

        .operation-flow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 1.5rem 0;
            padding: 1.5rem;
            background: var(--background);
            border-radius: 12px;
            border: 2px solid var(--border);
        }

        .operation-step {
            text-align: center;
            padding: 1rem;
            flex: 1;
            font-weight: 500;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .metric-box {
            padding: 1.25rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--surface);
            text-align: center;
        }

        .metric-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--primary);
            margin: 0.5rem 0;
        }

        .encryption-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .encryption-section {
            padding: 1rem;
            background: var(--background);
            border-radius: 8px;
            border: 2px solid var(--border);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîê NeoCrypt Omophonic System</h1>
            <p class="subtitle">Professional 256√ó256 S-Box Encryption with HMAC-SHA512</p>
        </header>

        <div class="grid-system">
            <!-- Left Panel -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üîë Key Configuration</h3>
                    </div>
                    
                    <div class="form-group">
                        <label>Master Password:</label>
                        <input type="password" id="crypto-key" value="secure-master-password-256bit" placeholder="Enter strong password">
                    </div>

                    <div class="form-group">
                        <label>Key Derivation Iterations:</label>
                        <input type="number" id="key-iterations" value="100000" min="10000">
                    </div>

                    <button class="btn" onclick="initializeSystem()">
                        üöÄ Initialize Crypto System
                    </button>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üß™ System Validation</h3>
                    </div>
                    
                    <button class="btn" onclick="runAllTests()">
                        ‚úÖ Run Comprehensive Tests
                    </button>

                    <button class="btn btn-secondary" onclick="testReversibility()">
                        üîÑ Test Reversibility
                    </button>

                    <button class="btn btn-secondary" onclick="testHomomorphicProperties()">
                        üßÆ Test Homomorphism
                    </button>

                    <button class="btn btn-secondary" onclick="testCryptographicSecurity()">
                        üîí Test Security
                    </button>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üìä System Status</h3>
                    </div>
                    
                    <div class="result-area">
                        <div class="status-item">
                            <span class="status-indicator status-danger"></span>
                            <span>S-Box: <span id="status-sbox">NOT INITIALIZED</span></span>
                        </div>
                        <div class="status-item">
                            <span class="status-indicator status-danger"></span>
                            <span>Crypto Core: <span id="status-crypto">OFFLINE</span></span>
                        </div>
                        <div class="status-item">
                            <span class="status-indicator status-danger"></span>
                            <span>Homomorphic Engine: <span id="status-homo">OFFLINE</span></span>
                        </div>
                        <div class="status-item">
                            <span class="status-indicator status-danger"></span>
                            <span>Validation: <span id="status-test">PENDING</span></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üî¢ Encryption & Decryption</h3>
                    </div>
                    
                    <div class="encryption-panel">
                        <div class="encryption-section">
                            <div class="form-group">
                                <label>Value to Encrypt (0-255):</label>
                                <input type="number" id="encrypt-input" value="42" min="0" max="255">
                            </div>
                            <button class="btn" onclick="encryptValue()">
                                üîí Encrypt
                            </button>
                            <div class="result-area" id="encrypt-result" style="margin-top: 1rem; min-height: 60px;">
                                Result will appear here
                            </div>
                        </div>

                        <div class="encryption-section">
                            <div class="form-group">
                                <label>Omophone to Decrypt (0-65535):</label>
                                <input type="number" id="decrypt-input" value="0" min="0" max="65535">
                            </div>
                            <button class="btn" onclick="decryptValue()">
                                üîì Decrypt
                            </button>
                            <div class="result-area" id="decrypt-result" style="margin-top: 1rem; min-height: 60px;">
                                Result will appear here
                            </div>
                        </div>
                    </div>

                    <div class="operation-flow">
                        <div class="operation-step">A ‚Üí Encrypt ‚Üí</div>
                        <div class="operation-step" style="color: var(--primary); font-size: 1.5rem;">+</div>
                        <div class="operation-step">B ‚Üí Encrypt ‚Üí</div>
                        <div class="operation-step" style="color: var(--primary); font-size: 1.5rem;">=</div>
                        <div class="operation-step">‚Üê Decrypt ‚Üê</div>
                    </div>

                    <div class="form-group">
                        <label>Value A:</label>
                        <input type="number" id="input-a" value="42" min="0" max="255">
                    </div>

                    <div class="form-group">
                        <label>Value B:</label>
                        <input type="number" id="input-b" value="17" min="0" max="255">
                    </div>

                    <button class="btn" onclick="performHomomorphicAddition()">
                        ‚ûï Execute Homomorphic Addition
                    </button>

                    <div class="result-area" id="operation-result">
                        Homomorphic operation results will appear here
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üìà Validation Results</h3>
                    </div>
                    
                    <div class="result-area" id="test-results">
                        <div class="test-result test-fail">
                            <span>‚ùå</span>
                            <div>Reversibility: NOT TESTED</div>
                        </div>
                        <div class="test-result test-fail">
                            <span>‚ùå</span>
                            <div>Homomorphism: NOT TESTED</div>
                        </div>
                        <div class="test-result test-fail">
                            <span>‚ùå</span>
                            <div>Security: NOT TESTED</div>
                        </div>
                        <div class="test-result test-fail">
                            <span>‚ùå</span>
                            <div>Performance: NOT TESTED</div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">üìä System Metrics</h3>
                    </div>
                    
                    <div class="metric-grid">
                        <div class="metric-box">
                            <div>Entropy Quality</div>
                            <div class="metric-value" id="metric-entropy">0.00</div>
                            <div>bits/byte</div>
                        </div>
                        <div class="metric-box">
                            <div>Avalanche Effect</div>
                            <div class="metric-value" id="metric-avalanche">0%</div>
                            <div>bit diffusion</div>
                        </div>
                        <div class="metric-box">
                            <div>Operations Speed</div>
                            <div class="metric-value" id="metric-speed">0</div>
                            <div>ops/second</div>
                        </div>
                        <div class="metric-box">
                            <div>System Integrity</div>
                            <div class="metric-value" id="metric-errors">0</div>
                            <div>errors</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =============================================================================
        // PROFESSIONAL OMOPHONIC CRYPTO SYSTEM
        // =============================================================================

        class ProfessionalOmophonicCrypto {
            constructor() {
                this.initialized = false;
                this.sBox = new Map();
                this.inverseSBox = new Map();
                this.encryptionKey = null;
                this.hmacKey = null;
                this.iv = null;
                
                this.testResults = {
                    reversibility: { passed: false, message: "Not tested" },
                    homomorphic: { passed: false, message: "Not tested" },
                    security: { passed: false, message: "Not tested" },
                    performance: { passed: false, message: "Not tested" }
                };
                
                this.metrics = {
                    entropy: 0,
                    avalanche: 0,
                    speed: 0,
                    errors: 0
                };
            }

            async initializeSystem(password, iterations = 100000) {
                try {
                    console.log("üîß Initializing cryptographic system...");
                    
                    // Clear previous state
                    this.sBox.clear();
                    this.inverseSBox.clear();
                    
                    // Derive keys using proper PBKDF2
                    await this.deriveKeys(password, iterations);
                    
                    // Generate S-Box using HMAC-SHA512
                    await this.generateSBox();
                    
                    // Initialize IV
                    this.iv = crypto.getRandomValues(new Uint16Array(1))[0];
                    
                    this.initialized = true;
                    console.log("‚úÖ System initialized successfully");
                    
                    // Run initial tests
                    await this.runInitialTests();
                    
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå Initialization failed:', error);
                    this.metrics.errors++;
                    return false;
                }
            }

            async deriveKeys(password, iterations) {
                const encoder = new TextEncoder();
                const passwordBuffer = encoder.encode(password);
                
                // Create salt for key derivation
                const salt = crypto.getRandomValues(new Uint8Array(16));
                
                const importedKey = await crypto.subtle.importKey(
                    'raw',
                    passwordBuffer,
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits']
                );
                
                // Derive 512 bits (256 for encryption, 256 for HMAC)
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: iterations,
                        hash: 'SHA-512'
                    },
                    importedKey,
                    512
                );
                
                const derivedArray = new Uint8Array(derivedBits);
                this.encryptionKey = derivedArray.slice(0, 32);
                this.hmacKey = derivedArray.slice(32, 64);
            }

            async generateSBox() {
                console.log("üîÑ Generating 256√ó256 S-Box with HMAC-SHA512...");
                
                for (let byteValue = 0; byteValue < 256; byteValue++) {
                    const omophones = new Set();
                    
                    while (omophones.size < 256) {
                        const omophone = await this.generateOmophone(byteValue, omophones.size);
                        if (!this.inverseSBox.has(omophone)) {
                            omophones.add(omophone);
                            this.inverseSBox.set(omophone, byteValue);
                        }
                    }
                    
                    this.sBox.set(byteValue, Array.from(omophones));
                }
                
                console.log("‚úÖ S-Box generation completed");
            }

            async generateOmophone(byteValue, index) {
                // Create unique data for HMAC
                const hmacData = new TextEncoder().encode(`${byteValue}-${index}-${Date.now()}`);
                
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    this.hmacKey,
                    { name: 'HMAC', hash: 'SHA-512' },
                    false,
                    ['sign']
                );
                
                const signature = await crypto.subtle.sign('HMAC', cryptoKey, hmacData);
                const signatureArray = new Uint8Array(signature);
                
                // Create 16-bit omophone from HMAC output
                let omophone = 0;
                for (let i = 0; i < 16; i++) {
                    omophone = (omophone << 8) | signatureArray[i];
                }
                
                return omophone & 0xFFFF; // Ensure 16-bit value
            }

            async encryptByte(byteValue) {
                if (!this.initialized) throw new Error("System not initialized");
                if (byteValue < 0 || byteValue > 255) throw new Error("Byte value must be 0-255");
                
                const omophones = this.sBox.get(byteValue);
                if (!omophones) throw new Error("S-Box not properly initialized");
                
                const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0];
                return omophones[randomIndex];
            }

            async decryptOmophone(omophone) {
                if (!this.initialized) throw new Error("System not initialized");
                
                const result = this.inverseSBox.get(omophone);
                if (result === undefined) throw new Error("Invalid omophone: not found in inverse S-Box");
                
                return result;
            }

            async homomorphicAdd(omoA, omoB) {
                // Simple modular addition for homomorphic property
                return (omoA + omoB) % 65536;
            }

            // =============================================================================
            // VALIDATION AND TESTING
            // =============================================================================

            async runInitialTests() {
                this.testResults.reversibility = await this.testReversibility();
                this.testResults.homomorphic = await this.testHomomorphicProperties();
                this.testResults.security = await this.testSecurity();
                this.testResults.performance = await this.testPerformance();
                
                await this.calculateMetrics();
            }

            async testReversibility() {
                const testCases = 100;
                let passed = 0;
                
                for (let i = 0; i < testCases; i++) {
                    try {
                        const testValue = Math.floor(Math.random() * 256);
                        const encrypted = await this.encryptByte(testValue);
                        const decrypted = await this.decryptOmophone(encrypted);
                        
                        if (decrypted === testValue) passed++;
                    } catch (error) {
                        console.error("Reversibility test error:", error);
                    }
                }
                
                return {
                    passed: passed === testCases,
                    message: `${passed}/${testCases} tests passed`
                };
            }

            async testHomomorphicProperties() {
                const testCases = 50;
                let passed = 0;
                
                for (let i = 0; i < testCases; i++) {
                    try {
                        const a = Math.floor(Math.random() * 100);
                        const b = Math.floor(Math.random() * 100);
                        
                        const encA = await this.encryptByte(a);
                        const encB = await this.encryptByte(b);
                        const encSum = await this.homomorphicAdd(encA, encB);
                        const decrypted = await this.decryptOmophone(encSum);
                        
                        if (decrypted === (a + b) % 256) passed++;
                    } catch (error) {
                        console.error("Homomorphism test error:", error);
                    }
                }
                
                return {
                    passed: passed === testCases,
                    message: `${passed}/${testCases} tests passed`
                };
            }

            async testSecurity() {
                try {
                    const avalanche = await this.testAvalancheEffect();
                    const entropy = await this.testEntropy();
                    
                    return {
                        passed: avalanche && entropy,
                        message: `Avalanche: ${avalanche ? '‚úì' : '‚úó'}, Entropy: ${entropy ? '‚úì' : '‚úó'}`
                    };
                } catch (error) {
                    return { passed: false, message: `Security test failed: ${error.message}` };
                }
            }

            async testAvalancheEffect() {
                const testCases = 100;
                let totalChange = 0;
                
                for (let i = 0; i < testCases; i++) {
                    const input = Math.floor(Math.random() * 256);
                    const input2 = (input + 1) % 256;
                    
                    const enc1 = await this.encryptByte(input);
                    const enc2 = await this.encryptByte(input2);
                    
                    const diff = enc1 ^ enc2;
                    let changedBits = 0;
                    for (let j = 0; j < 16; j++) {
                        if (diff & (1 << j)) changedBits++;
                    }
                    
                    totalChange += (changedBits / 16) * 100;
                }
                
                this.metrics.avalanche = totalChange / testCases;
                return this.metrics.avalanche > 45;
            }

            async testEntropy() {
                const samples = 1000;
                const frequency = new Map();
                
                for (let i = 0; i < samples; i++) {
                    const value = Math.floor(Math.random() * 256);
                    const encrypted = await this.encryptByte(value);
                    frequency.set(encrypted, (frequency.get(encrypted) || 0) + 1);
                }
                
                let entropy = 0;
                const total = samples;
                
                for (const count of frequency.values()) {
                    const probability = count / total;
                    entropy -= probability * Math.log2(probability);
                }
                
                this.metrics.entropy = entropy;
                return entropy > 14;
            }

            async testPerformance() {
                const start = performance.now();
                const operations = 100;
                
                for (let i = 0; i < operations; i++) {
                    await this.encryptByte(Math.floor(Math.random() * 256));
                }
                
                const duration = performance.now() - start;
                this.metrics.speed = Math.round(operations / (duration / 1000));
                return this.metrics.speed > 10;
            }

            async calculateMetrics() {
                this.metrics.entropy = Number(this.metrics.entropy.toFixed(2));
                this.metrics.avalanche = Number(this.metrics.avalanche.toFixed(1));
            }
        }

        // =============================================================================
        // UI MANAGEMENT
        // =============================================================================

        const cryptoSystem = new ProfessionalOmophonicCrypto();

        async function initializeSystem() {
            const password = document.getElementById('crypto-key').value;
            const iterations = parseInt(document.getElementById('key-iterations').value);
            
            if (!password) {
                alert("Please enter a master password");
                return;
            }
            
            updateStatus('sbox', 'warning', 'Generating S-Box...');
            updateStatus('crypto', 'warning', 'Deriving keys...');
            updateStatus('homo', 'warning', 'Initializing...');
            updateStatus('test', 'warning', 'Pending...');
            
            const success = await cryptoSystem.initializeSystem(password, iterations);
            
            if (success) {
                updateStatus('sbox', 'active', 'Ready');
                updateStatus('crypto', 'active', 'Operational');
                updateStatus('homo', 'active', 'Active');
                updateStatus('test', 'active', 'Tests passed');
                
                updateTestResults();
                updateMetrics();
                alert("‚úÖ System initialized successfully!");
            } else {
                updateStatus('sbox', 'danger', 'Failed');
                updateStatus('crypto', 'danger', 'Failed');
                updateStatus('homo', 'danger', 'Failed');
                updateStatus('test', 'danger', 'Tests failed');
                alert("‚ùå System initialization failed. Check console for details.");
            }
        }

        async function encryptValue() {
            try {
                const value = parseInt(document.getElementById('encrypt-input').value);
                if (isNaN(value) || value < 0 || value > 255) {
                    throw new Error("Please enter a valid byte value (0-255)");
                }
                
                const encrypted = await cryptoSystem.encryptByte(value);
                document.getElementById('encrypt-result').innerHTML = `
                    <strong>Input:</strong> ${value}<br>
                    <strong>Encrypted:</strong> ${encrypted}<br>
                    <strong>Hex:</strong> 0x${encrypted.toString(16).toUpperCase()}
                `;
            } catch (error) {
                document.getElementById('encrypt-result').innerHTML = `
                    <span style="color: var(--danger);">Error: ${error.message}</span>
                `;
            }
        }

        async function decryptValue() {
            try {
                const value = parseInt(document.getElementById('decrypt-input').value);
                if (isNaN(value) || value < 0 || value > 65535) {
                    throw new Error("Please enter a valid omophone value (0-65535)");
                }
                
                const decrypted = await cryptoSystem.decryptOmophone(value);
                document.getElementById('decrypt-result').innerHTML = `
                    <strong>Input:</strong> ${value}<br>
                    <strong>Decrypted:</strong> ${decrypted}<br>
                    <strong>Hex:</strong> 0x${decrypted.toString(16).toUpperCase()}
                `;
            } catch (error) {
                document.getElementById('decrypt-result').innerHTML = `
                    <span style="color: var(--danger);">Error: ${error.message}</span>
                `;
            }
        }

        async function performHomomorphicAddition() {
            try {
                const a = parseInt(document.getElementById('input-a').value);
                const b = parseInt(document.getElementById('input-b').value);
                
                if (isNaN(a) || a < 0 || a > 255 || isNaN(b) || b < 0 || b > 255) {
                    throw new Error("Both values must be between 0-255");
                }
                
                const encA = await cryptoSystem.encryptByte(a);
                const encB = await cryptoSystem.encryptByte(b);
                const encSum = await cryptoSystem.homomorphicAdd(encA, encB);
                const result = await cryptoSystem.decryptOmophone(encSum);
                const expected = (a + b) % 256;
                
                document.getElementById('operation-result').innerHTML = `
                    <strong>A = ${a}</strong> ‚Üí Encrypted: ${encA}<br>
                    <strong>B = ${b}</strong> ‚Üí Encrypted: ${encB}<br>
                    <strong>Encrypted Sum:</strong> ${encSum}<br>
                    <strong>Decrypted Result:</strong> ${result}<br>
                    <strong>Expected:</strong> ${expected}<br><br>
                    <span style="color: ${result === expected ? 'var(--success)' : 'var(--danger)'}; 
                                 font-weight: bold;">
                        ${result === expected ? '‚úÖ SUCCESS: Homomorphic addition works!' : '‚ùå FAILED: Result mismatch'}
                    </span>
                `;
                
            } catch (error) {
                document.getElementById('operation-result').innerHTML = `
                    <span style="color: var(--danger);">Error: ${error.message}</span>
                `;
            }
        }

        async function runAllTests() {
            updateStatus('test', 'warning', 'Running tests...');
            await cryptoSystem.runInitialTests();
            updateTestResults();
            updateMetrics();
            updateStatus('test', 'active', 'Tests completed');
        }

        async function testReversibility() {
            const result = await cryptoSystem.testReversibility();
            updateTestResult('reversibility', result);
        }

        async function testHomomorphicProperties() {
            const result = await cryptoSystem.testHomomorphicProperties();
            updateTestResult('homomorphic', result);
        }

        async function testCryptographicSecurity() {
            const result = await cryptoSystem.testSecurity();
            updateTestResult('security', result);
        }

        function updateTestResult(testName, result) {
            const tests = ['reversibility', 'homomorphic', 'security', 'performance'];
            const index = tests.indexOf(testName);
            const element = document.querySelector(`#test-results .test-result:nth-child(${index + 1})`);
            
            if (element) {
                element.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                element.innerHTML = `<span>${result.passed ? '‚úÖ' : '‚ùå'}</span><div>${testName}: ${result.message}</div>`;
            }
        }

        function updateTestResults() {
            updateTestResult('reversibility', cryptoSystem.testResults.reversibility);
            updateTestResult('homomorphic', cryptoSystem.testResults.homomorphic);
            updateTestResult('security', cryptoSystem.testResults.security);
            updateTestResult('performance', cryptoSystem.testResults.performance);
        }

        function updateMetrics() {
            document.getElementById('metric-entropy').textContent = cryptoSystem.metrics.entropy;
            document.getElementById('metric-avalanche').textContent = cryptoSystem.metrics.avalanche + '%';
            document.getElementById('metric-speed').textContent = cryptoSystem.metrics.speed.toLocaleString();
            document.getElementById('metric-errors').textContent = cryptoSystem.metrics.errors;
        }

        function updateStatus(element, status, text) {
            const indicator = document.getElementById(`status-${element}-indicator`);
            const textElement = document.getElementById(`status-${element}`);
            
            if (indicator && textElement) {
                indicator.className = `status-indicator status-${status}`;
                textElement.textContent = text;
            }
        }

        // Initialize UI
        window.addEventListener('load', () => {
            updateStatus('sbox', 'danger', 'Not initialized');
            updateStatus('crypto', 'danger', 'Offline');
            updateStatus('homo', 'danger', 'Offline');
            updateStatus('test', 'danger', 'Pending');
        });
    </script>
</body>
</html>
