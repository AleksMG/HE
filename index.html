<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≥–æ–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∞—è –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º–∞</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --border: #30363d;
        }
        
        body { 
            font-family: 'Consolas', 'Monaco', monospace; 
            margin: 0; 
            padding: 20px; 
            background: var(--bg-primary); 
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        .container { 
            max-width: 1600px; 
            margin: 0 auto; 
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        h1, h2, h3 {
            color: var(--accent);
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border);
            margin-bottom: 20px;
        }
        
        .card-title {
            font-size: 1.2em;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
            color: var(--accent);
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            box-sizing: border-box;
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        button {
            background: var(--success);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
            margin: 5px;
        }
        
        button:hover {
            background: #2ea043;
        }
        
        button.secondary {
            background: var(--bg-tertiary);
        }
        
        button.secondary:hover {
            background: #30363d;
        }
        
        button.warning {
            background: var(--warning);
        }
        
        button.warning:hover {
            background: #bb8009;
        }
        
        .output {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 4px;
            margin-top: 10px;
            white-space: pre-wrap;
            overflow-x: auto;
            font-family: monospace;
        }
        
        .analysis-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1000px) {
            .analysis-panel {
                grid-template-columns: 1fr;
            }
        }
        
        .metric {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        .metric-title {
            font-size: 1em;
            margin-top: 0;
            color: var(--text-secondary);
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--accent);
        }
        
        .test-results {
            margin-top: 20px;
        }
        
        .test-item {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
        }
        
        .test-pass { color: var(--success); }
        .test-warn { color: var(--warning); }
        .test-fail { color: var(--danger); }
        
        .recommendations {
            background: var(--bg-secondary);
            padding: 20px;
            border-left: 4px solid var(--accent);
            margin: 20px 0;
        }
        
        .mono {
            font-family: monospace;
        }
        
        .flex-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
        }
        
        .tab.active {
            background: var(--bg-secondary);
            border-color: var(--border);
            color: var(--accent);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .sbox-table {
            display: grid;
            grid-template-columns: repeat(17, 1fr);
            gap: 1px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.7em;
        }
        
        .sbox-header {
            background: var(--bg-tertiary);
            padding: 5px;
            text-align: center;
            font-weight: bold;
        }
        
        .sbox-cell {
            background: var(--bg-tertiary);
            padding: 5px;
            text-align: center;
        }
        
        .sbox-index {
            background: var(--bg-tertiary);
            padding: 5px;
            text-align: center;
            font-weight: bold;
        }
        
        .progress-bar {
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.5s;
        }
        
        .histogram {
            display: flex;
            height: 200px;
            align-items: flex-end;
            gap: 1px;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        
        .bar {
            background: var(--accent);
            flex: 1;
            min-width: 1px;
        }
        
        .byte-distribution {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
            margin-top: 15px;
        }
        
        .byte-cell {
            height: 20px;
            background: var(--bg-tertiary);
            position: relative;
        }
        
        .byte-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--accent);
            height: 0%;
        }
        
        .byte-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7em;
            color: white;
            text-shadow: 0 0 2px black;
        }
        
        .test-details {
            background: var(--bg-tertiary);
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 0.9em;
        }
        
        .avalanche-results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }
        
        .avalanche-chart {
            height: 300px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        
        .avalanche-bar {
            background: var(--accent);
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîê –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≥–æ–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∞—è –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º–∞</h1>
            <p>–£–ª—É—á—à–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–µ–¥–æ–≤—ã—Ö –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤</p>
        </header>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('encryption')">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</div>
            <div class="tab" onclick="switchTab('analysis')">–ê–Ω–∞–ª–∏–∑</div>
            <div class="tab" onclick="switchTab('sbox')">S-Box –∞–Ω–∞–ª–∏–∑</div>
        </div>
        
        <div id="encryption" class="tab-content active">
            <div class="grid">
                <div class="card">
                    <h2 class="card-title">–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
                    
                    <div class="input-group">
                        <label for="keyInput">–ö–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
                        <input type="password" id="keyInput" value="super-secure-key-with-high-entropy">
                    </div>
                    
                    <div class="input-group">
                        <label for="keyConfirmation">–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–ª—é—á–∞:</label>
                        <input type="password" id="keyConfirmation" value="super-secure-key-with-high-entropy">
                    </div>
                    
                    <div class="input-group">
                        <label for="pbkdf2Iterations">PBKDF2 –ò—Ç–µ—Ä–∞—Ü–∏–∏:</label>
                        <select id="pbkdf2Iterations">
                            <option value="100000">100,000 (—Å—Ç–∞–Ω–¥–∞—Ä—Ç)</option>
                            <option value="250000">250,000 (—É—Å–∏–ª–µ–Ω–Ω—ã–π)</option>
                            <option value="500000" selected>500,000 (–≤–æ–µ–Ω–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å)</option>
                            <option value="1000000">1,000,000 (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π)</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="operationMode">–†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã:</label>
                        <select id="operationMode">
                            <option value="cbc" selected>CBC (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)</option>
                            <option value="ecb">ECB</option>
                            <option value="nodiffusion">–ë–µ–∑ –¥–∏—Ñ—Ñ—É–∑–∏–∏</option>
                        </select>
                    </div>
                    
                    <button onclick="initializeCipher()" class="warning">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —à–∏—Ñ—Ä</button>
                    
                    <div class="output" id="initStatus">–®–∏—Ñ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω</div>
                </div>
                
                <div class="card">
                    <h2 class="card-title">–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö</h2>
                    
                    <div class="input-group">
                        <label for="inputData">–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:</label>
                        <textarea id="inputData">–ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, —Ç—Ä–µ–±—É—é—â–∞—è –≤—ã—Å—à–µ–≥–æ —É—Ä–æ–≤–Ω—è –∑–∞—â–∏—Ç—ã</textarea>
                    </div>
                    
                    <div class="flex-row">
                        <button onclick="encryptData()">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                        <button onclick="decryptData()">–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                        <button onclick="clearAll()" class="secondary">–û—á–∏—Å—Ç–∏—Ç—å</button>
                    </div>
                    
                    <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç:</h3>
                    <div class="output" id="outputData">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å</div>
                    
                    <h3>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏:</h3>
                    <div class="output" id="encryptionInfo">–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ—Ü–µ—Å—Å–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</div>
                </div>
            </div>
        </div>
        
        <div id="analysis" class="tab-content">
            <div class="card">
                <h2 class="card-title">–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑</h2>
                
                <div class="flex-row">
                    <button onclick="runEntropyAnalysis()">–ê–Ω–∞–ª–∏–∑ —ç–Ω—Ç—Ä–æ–ø–∏–∏</button>
                    <button onclick="runFrequencyTest()">–ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑</button>
                    <button onclick="runAvalancheTest()">–¢–µ—Å—Ç –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞</button>
                    <button onclick="runRandomnessTests()">–¢–µ—Å—Ç—ã —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏</button>
                    <button onclick="runAllTests()">–ó–∞–ø—É—Å—Ç–∏—Ç—å –≤—Å–µ —Ç–µ—Å—Ç—ã</button>
                </div>
                
                <div class="analysis-panel">
                    <div>
                        <h3>–ú–µ—Ç—Ä–∏–∫–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö</h3>
                        
                        <div class="metric">
                            <div class="metric-title">–≠–Ω—Ç—Ä–æ–ø–∏—è –®–µ–Ω–Ω–æ–Ω–∞ (–±–∏—Ç/–±–∞–π—Ç)</div>
                            <div class="metric-value" id="shannonEntropy">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è (–±–∏—Ç/–±–∞–π—Ç)</div>
                            <div class="metric-value" id="minEntropy">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">œá¬≤ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</div>
                            <div class="metric-value" id="chiSquare">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">p-–∑–Ω–∞—á–µ–Ω–∏–µ</div>
                            <div class="metric-value" id="pValue">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">–û—Ü–µ–Ω–∫–∞ —á–∏—Å–ª–∞ œÄ</div>
                            <div class="metric-value" id="piEstimate">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ runs</div>
                            <div class="metric-value" id="runsCount">0</div>
                        </div>
                    </div>
                    
                    <div>
                        <h3>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è</h3>
                        <div class="histogram" id="byteHistogram">
                            <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ JavaScript -->
                        </div>
                        
                        <h3>–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –±–∞–π—Ç–æ–≤</h3>
                        <div class="byte-distribution" id="byteDistribution">
                            <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ JavaScript -->
                        </div>
                    </div>
                </div>
                
                <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞</h3>
                <div class="test-results" id="analysisResults">
                    <div class="test-item">–ê–Ω–∞–ª–∏–∑ –Ω–µ –ø—Ä–æ–≤–æ–¥–∏–ª—Å—è</div>
                </div>
            </div>
        </div>
        
        <div id="sbox" class="tab-content">
            <div class="card">
                <h2 class="card-title">–ê–Ω–∞–ª–∏–∑ S-Box</h2>
                
                <div class="flex-row">
                    <button onclick="analyzeSBox()">–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å S-Box</button>
                    <button onclick="visualizeSBox()">–í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å S-Box</button>
                </div>
                
                <h3>–°–≤–æ–π—Å—Ç–≤–∞ S-Box</h3>
                <div class="test-results" id="sboxProperties">
                    <div class="test-item">S-Box –Ω–µ –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª—Å—è</div>
                </div>
                
                <h3>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è S-Box (–ø–µ—Ä–≤—ã–µ 16x16 –∑–Ω–∞—á–µ–Ω–∏–π)</h3>
                <div class="sbox-table" id="sboxTable">
                    <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ JavaScript -->
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2 class="card-title">–ó–∞–∫–ª—é—á–µ–Ω–∏–µ</h2>
            
            <div class="recommendations">
                <h3>–û—Ü–µ–Ω–∫–∞ –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç–∏ —Å–∏—Å—Ç–µ–º—ã:</h3>
                
                <div class="metric">
                    <div class="metric-title">–°—Ç–æ–π–∫–æ—Å—Ç—å –∫ —á–∞—Å—Ç–æ—Ç–Ω–æ–º—É –∞–Ω–∞–ª–∏–∑—É</div>
                    <div class="metric-value" id="frequencyResistance">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <div class="metric">
                    <div class="metric-title">–õ–∞–≤–∏–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç</div>
                    <div class="metric-value" id="avalancheEffect">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <div class="metric">
                    <div class="metric-title">–≠–Ω—Ç—Ä–æ–ø–∏–π–Ω–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å</div>
                    <div class="metric-value" id="entropyEfficiency">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <div class="metric">
                    <div class="metric-title">–î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Å—Ç–æ–π–∫–æ—Å—Ç—å</div>
                    <div class="metric-value" id="differentialResistance">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <p>–î–∞–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —É–ª—É—á—à–µ–Ω–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–∏—Ç–∏–≤—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∞—à–µ–π —Å–∏—Å—Ç–µ–º—ã —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ enhancements –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏.</p>
            </div>
        </div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º—ã
        let cipherInstance = null;
        let sBox = null;
        let inverseSBox = null;
        let lastOperationResult = null;
        let lastEncryptedData = null;
        
        // –ö–ª–∞—Å—Å –¥–ª—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –≥–æ–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–æ–π –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º—ã
        class ProfessionalHomophonicCipher {
            constructor() {
                this.sBox = null;
                this.inverseSBox = null;
                this.encryptionKey = null;
                this.initializationVector = null;
            }
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —à–∏—Ñ—Ä–∞ —Å –∫–ª—é—á–æ–º
            async initializeWithKey(passphrase, iterations = 500000) {
                try {
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º PBKDF2
                    const encoder = new TextEncoder();
                    const passphraseData = encoder.encode(passphrase);
                    
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å–æ–ª—å –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏ (–ø–æ –≤–∞—à–µ–º—É —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é)
                    const salt = await crypto.subtle.digest('SHA-256', passphraseData);
                    
                    const keyMaterial = await crypto.subtle.importKey(
                        'raw',
                        passphraseData,
                        { name: 'PBKDF2' },
                        false,
                        ['deriveKey']
                    );
                    
                    this.encryptionKey = await crypto.subtle.deriveKey(
                        {
                            name: 'PBKDF2',
                            salt: salt,
                            iterations: iterations,
                            hash: 'SHA-512'
                        },
                        keyMaterial,
                        { name: 'HMAC', hash: 'SHA-512', length: 512 },
                        false,
                        ['sign']
                    );
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è S-Box –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
                    await this.generateSBox();
                    
                    return true;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —à–∏—Ñ—Ä: ' + error.message);
                }
            }
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è S-Box –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞ (—É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
            async generateSBox() {
                try {
                    const encoder = new TextEncoder();
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è seed –¥–ª—è S-Box –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
                    const sboxSeed = await crypto.subtle.sign(
                        'HMAC', 
                        this.encryptionKey, 
                        encoder.encode('sbox-generation-seed')
                    );
                    
                    const sboxSeedBytes = new Uint8Array(sboxSeed);
                    
                    // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö 16-–±–∏—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π (0-65535)
                    const allHomophones = new Array(65536);
                    for (let i = 0; i < 65536; i++) {
                        allHomophones[i] = i;
                    }
                    
                    // –¢—â–∞—Ç–µ–ª—å–Ω–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º HMAC –∫–∞–∫ CSPRNG
                    await this.fisherYatesShuffle(allHomophones, sboxSeedBytes);
                    
                    // –°–æ–∑–¥–∞–Ω–∏–µ S-Box 256x256
                    this.sBox = new Array(256);
                    this.inverseSBox = new Map();
                    
                    let homophoneIndex = 0;
                    for (let inputByte = 0; inputByte < 256; inputByte++) {
                        this.sBox[inputByte] = new Array(256);
                        for (let substitutionIndex = 0; substitutionIndex < 256; substitutionIndex++) {
                            const homophone = allHomophones[homophoneIndex++];
                            this.sBox[inputByte][substitutionIndex] = homophone;
                            this.inverseSBox.set(homophone, inputByte);
                        }
                    }
                    
                    return true;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ S-Box:', error);
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å S-Box: ' + error.message);
                }
            }
            
            // –ê–ª–≥–æ—Ä–∏—Ç–º –§–∏—à–µ—Ä–∞-–ô–µ–π—Ç—Å–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º HMAC –∫–∞–∫ CSPRNG
            async fisherYatesShuffle(array, seedBytes) {
                const hmacKey = await crypto.subtle.importKey(
                    'raw',
                    seedBytes,
                    { name: 'HMAC', hash: 'SHA-512' },
                    false,
                    ['sign']
                );
                
                let counter = 0;
                let randomBuffer = new Uint8Array(0);
                let bufferPosition = 0;
                
                for (let i = array.length - 1; i > 0; i--) {
                    if (bufferPosition >= randomBuffer.length - 1) {
                        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ —Å–ª—É—á–∞–π–Ω—ã–µ –±–∞–π—Ç—ã –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
                        const counterData = new Uint8Array([counter++]);
                        randomBuffer = new Uint8Array(await crypto.subtle.sign('HMAC', hmacKey, counterData));
                        bufferPosition = 0;
                    }
                    
                    // –ü–æ–ª—É—á–∞–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –±—É—Ñ–µ—Ä–∞
                    const randValue = (randomBuffer[bufferPosition] << 8) | randomBuffer[bufferPosition + 1];
                    bufferPosition += 2;
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –∏–Ω–¥–µ–∫—Å –¥–ª—è –æ–±–º–µ–Ω–∞
                    const j = randValue % (i + 1);
                    
                    // –û–±–º–µ–Ω –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            async encrypt(plaintext, mode = 'cbc') {
                try {
                    const encoder = new TextEncoder();
                    const plaintextBytes = encoder.encode(plaintext);
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è 16-–±–∞–π—Ç–Ω–æ–≥–æ IV (–∫—Ä–æ–º–µ —Ä–µ–∂–∏–º–∞ ECB)
                    if (mode !== 'ecb') {
                        this.initializationVector = crypto.getRandomValues(new Uint8Array(16));
                    }
                    
                    let ciphertext = new Uint16Array(plaintextBytes.length);
                    let previousBlock = this.initializationVector;
                    
                    // –ü—Ä–æ—Ü–µ—Å—Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                    for (let i = 0; i < plaintextBytes.length; i++) {
                        let byteToEncrypt = plaintextBytes[i];
                        
                        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ —Ä–∞–±–æ—Ç—ã
                        if (mode === 'cbc') {
                            byteToEncrypt ^= previousBlock[i % 16];
                        }
                        
                        // –°–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä –æ–º–æ—Ñ–æ–Ω–∞ –∏–∑ S-Box
                        const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0];
                        const homophone = this.sBox[byteToEncrypt][randomIndex];
                        
                        ciphertext[i] = homophone;
                        
                        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–ª–æ–∫–∞ –¥–ª—è —Ä–µ–∂–∏–º–æ–≤ —Å –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑—å—é
                        if (mode === 'cbc') {
                            previousBlock = this.updateDiffusionBlock(previousBlock, homophone);
                        }
                    }
                    
                    // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∏—Ç–æ–≥–æ–≤–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                    let result;
                    if (mode === 'ecb') {
                        // –î–ª—è ECB –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º IV
                        result = new Uint8Array(ciphertext.length * 2);
                        const ciphertextBytes = new Uint8Array(ciphertext.buffer);
                        result.set(ciphertextBytes, 0);
                    } else {
                        // –î–ª—è CBC –∏ NoDiffusion –¥–æ–±–∞–≤–ª—è–µ–º IV
                        result = new Uint8Array(16 + ciphertext.length * 2);
                        result.set(this.initializationVector, 0);
                        const ciphertextBytes = new Uint8Array(ciphertext.buffer);
                        result.set(ciphertextBytes, 16);
                    }
                    
                    return result;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:', error);
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ: ' + error.message);
                }
            }
            
            // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            async decrypt(ciphertext, mode = 'cbc') {
                try {
                    let iv, encryptedData;
                    
                    if (mode === 'ecb') {
                        // –î–ª—è ECB –Ω–µ—Ç IV
                        if (ciphertext.length % 2 !== 0) {
                            throw new Error('–ù–µ–≤–µ—Ä–Ω–∞—è –¥–ª–∏–Ω–∞ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö');
                        }
                        iv = new Uint8Array(16).fill(0); // –ü—É—Å—Ç–æ–π IV –¥–ª—è ECB
                        encryptedData = ciphertext;
                    } else {
                        // –î–ª—è CBC –∏ NoDiffusion –∏–∑–≤–ª–µ–∫–∞–µ–º IV –∏–∑ –Ω–∞—á–∞–ª–∞ –¥–∞–Ω–Ω—ã—Ö
                        if (ciphertext.length < 16) {
                            throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö');
                        }
                        iv = ciphertext.slice(0, 16);
                        encryptedData = ciphertext.slice(16);
                    }
                    
                    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ Uint16Array –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–º–æ—Ñ–æ–Ω–æ–≤
                    if (encryptedData.length % 2 !== 0) {
                        throw new Error('–ù–µ–≤–µ—Ä–Ω–∞—è –¥–ª–∏–Ω–∞ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö');
                    }
                    
                    const homophones = new Uint16Array(encryptedData.buffer, 0, encryptedData.length / 2);
                    const plaintext = new Uint8Array(homophones.length);
                    
                    let previousBlock = iv;
                    
                    // –ü—Ä–æ—Ü–µ—Å—Å –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                    for (let i = 0; i < homophones.length; i++) {
                        const homophone = homophones[i];
                        
                        if (!this.inverseSBox.has(homophone)) {
                            throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π –æ–º–æ—Ñ–æ–Ω –≤ –ø–æ–∑–∏—Ü–∏–∏ ${i}: ${homophone}`);
                        }
                        
                        let decryptedByte = this.inverseSBox.get(homophone);
                        
                        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ —Ä–∞–±–æ—Ç—ã
                        if (mode === 'cbc') {
                            decryptedByte ^= previousBlock[i % 16];
                        }
                        
                        plaintext[i] = decryptedByte;
                        
                        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–ª–æ–∫–∞ –¥–ª—è —Ä–µ–∂–∏–º–æ–≤ —Å –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑—å—é
                        if (mode === 'cbc') {
                            previousBlock = this.updateDiffusionBlock(previousBlock, homophone);
                        }
                    }
                    
                    const decoder = new TextDecoder();
                    return decoder.decode(plaintext);
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:', error);
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ: ' + error.message);
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–ª–æ–∫–∞ –¥–∏—Ñ—Ñ—É–∑–∏–∏ (–ø–æ –≤–∞—à–µ–º—É –ø—Ä–∏–º–µ—Ä—É)
            updateDiffusionBlock(block, homophone) {
                const newBlock = new Uint8Array(16);
                const homophoneBytes = new Uint8Array([
                    (homophone >> 8) & 0xFF,
                    homophone & 0xFF
                ]);
                
                for (let i = 0; i < 16; i++) {
                    newBlock[i] = block[i] ^ homophoneBytes[i % 2];
                }
                
                return newBlock;
            }
            
            // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ S-Box –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
            getSBoxProperties() {
                if (!this.sBox) return null;
                
                const properties = {
                    size: "256x256",
                    totalElements: 65536,
                    uniqueHomophones: new Set(),
                    byteCoverage: new Array(256).fill(0),
                    distribution: {}
                };
                
                // –ê–Ω–∞–ª–∏–∑ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ–º–æ—Ñ–æ–Ω–æ–≤
                for (let i = 0; i < 256; i++) {
                    for (let j = 0; j < 256; j++) {
                        const homophone = this.sBox[i][j];
                        properties.uniqueHomophones.add(homophone);
                        
                        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å—Ç–∞—Ä—à–∏–º –±–∞–π—Ç–∞–º
                        const highByte = (homophone >> 8) & 0xFF;
                        properties.byteCoverage[highByte]++;
                        
                        // –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π
                        if (!properties.distribution[homophone]) {
                            properties.distribution[homophone] = 0;
                        }
                        properties.distribution[homophone]++;
                    }
                }
                
                properties.uniqueHomophonesCount = properties.uniqueHomophones.size;
                properties.uniformityScore = this.calculateUniformity(properties.distribution);
                
                return properties;
            }
            
            // –†–∞—Å—á–µ—Ç —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç–∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
            calculateUniformity(distribution) {
                const values = Object.values(distribution);
                const expected = 256; // –ö–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –≤—Å—Ç—Ä–µ—á–∞—Ç—å—Å—è 256 —Ä–∞–∑ –≤ –∏–¥–µ–∞–ª–µ
                
                let chiSquare = 0;
                for (const count of values) {
                    chiSquare += Math.pow(count - expected, 2) / expected;
                }
                
                return chiSquare;
            }
        }
        
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        function calculateShannonEntropy(data) {
            if (!data || data.length === 0) return 0;
            
            const frequencies = new Array(256).fill(0);
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            let entropy = 0;
            for (let i = 0; i < 256; i++) {
                if (frequencies[i] > 0) {
                    const p = frequencies[i] / data.length;
                    entropy -= p * Math.log2(p);
                }
            }
            
            return entropy;
        }
        
        function calculateMinEntropy(data) {
            if (!data || data.length === 0) return 0;
            
            const frequencies = new Array(256).fill(0);
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            const maxFrequency = Math.max(...frequencies);
            const maxProbability = maxFrequency / data.length;
            
            return -Math.log2(maxProbability);
        }
        
        function calculateChiSquare(data) {
            if (!data || data.length === 0) return { chiSquare: 0, pValue: 0 };
            
            const expected = data.length / 256;
            const frequencies = new Array(256).fill(0);
            
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            let chiSquare = 0;
            for (let i = 0; i < 256; i++) {
                chiSquare += Math.pow(frequencies[i] - expected, 2) / expected;
            }
            
            // –ë–æ–ª–µ–µ —Ç–æ—á–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ p-–∑–Ω–∞—á–µ–Ω–∏—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞–ø–ø—Ä–æ–∫—Å–∏–º–∞—Ü–∏–∏
            const pValue = chiSquarePValue(chiSquare, 255);
            
            return { chiSquare, pValue };
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è p-–∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ö–∏-–∫–≤–∞–¥—Ä–∞—Ç
        function chiSquarePValue(chi2, df) {
            if (df <= 0) return 0;
            if (chi2 <= 0) return 1;
            
            // –ê–ø–ø—Ä–æ–∫—Å–∏–º–∞—Ü–∏—è –¥–ª—è –±–æ–ª—å—à–∏—Ö —Å—Ç–µ–ø–µ–Ω–µ–π —Å–≤–æ–±–æ–¥—ã (df > 30)
            const z = (Math.sqrt(2 * chi2) - Math.sqrt(2 * df - 1));
            return 1 - (1 + erf(z / Math.sqrt(2))) / 2;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –æ—à–∏–±–æ–∫ (error function)
        function erf(x) {
            // Approximation from Abramowitz and Stegun
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;
            
            const sign = Math.sign(x);
            x = Math.abs(x);
            
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return sign * y;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —á–∏—Å–ª–∞ œÄ –º–µ—Ç–æ–¥–æ–º –ú–æ–Ω—Ç–µ-–ö–∞—Ä–ª–æ
        function calculatePiEstimate(data) {
            if (!data || data.length < 2) return 0;
            
            let inCircle = 0;
            let totalPairs = 0;
            
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–∏ –±–∞–π—Ç–æ–≤
            for (let i = 0; i < data.length - 1; i += 2) {
                const x = data[i] / 255.0;       // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ [0, 1]
                const y = data[i + 1] / 255.0;   // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ [0, 1]
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ø–∞–¥–∞–µ—Ç –ª–∏ —Ç–æ—á–∫–∞ –≤ –µ–¥–∏–Ω–∏—á–Ω—É—é –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å
                if (x * x + y * y <= 1.0) {
                    inCircle++;
                }
                totalPairs++;
            }
            
            if (totalPairs === 0) return 0;
            
            // –û—Ü–µ–Ω–∫–∞ œÄ: (4 * —Ç–æ—á–∫–∏ –≤ –∫—Ä—É–≥–µ) / –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫
            return (4.0 * inCircle) / totalPairs;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ runs (—Å–µ—Ä–∏–π)
        function calculateRuns(data) {
            if (!data || data.length < 2) return 0;
            
            let runs = 1;
            let previous = data[0] >= 128; // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –±–∏–Ω–∞—Ä–Ω—É—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
            
            for (let i = 1; i < data.length; i++) {
                const current = data[i] >= 128;
                if (current !== previous) {
                    runs++;
                    previous = current;
                }
            }
            
            return runs;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∞–≤—Ç–æ–∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏
        function calculateAutocorrelation(data, lag = 1) {
            if (!data || data.length <= lag) return 0;
            
            const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
            let numerator = 0;
            let denominator = 0;
            
            for (let i = 0; i < data.length - lag; i++) {
                numerator += (data[i] - mean) * (data[i + lag] - mean);
                denominator += Math.pow(data[i] - mean, 2);
            }
            
            return numerator / denominator;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —á–∞—Å—Ç–æ—Ç–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
        function frequencyAnalysis(data) {
            if (!data || data.length === 0) return null;
            
            const frequencies = new Array(256).fill(0);
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            return frequencies;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ç–µ—Å—Ç–∞ –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
        async function runAvalancheTestInternal(cipher, originalData, mode = 'cbc') {
            if (!originalData || originalData.length === 0) {
                throw new Error("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ç–µ—Å—Ç–∞ –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞");
            }
            
            const encoder = new TextEncoder();
            const originalText = encoder.decode(originalData);
            
            // –®–∏—Ñ—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            const originalEncrypted = await cipher.encrypt(originalText, mode);
            
            // –ò–∑–º–µ–Ω—è–µ–º –æ–¥–∏–Ω –±–∏—Ç –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ —à–∏—Ñ—Ä—É–µ–º —Å–Ω–æ–≤–∞
            const modifiedData = new Uint8Array(originalData);
            modifiedData[0] ^= 0x01; // –ò–∑–º–µ–Ω—è–µ–º –ø–µ—Ä–≤—ã–π –±–∏—Ç –ø–µ—Ä–≤–æ–≥–æ –±–∞–π—Ç–∞
            
            const modifiedText = encoder.decode(modifiedData);
            const modifiedEncrypted = await cipher.encrypt(modifiedText, mode);
            
            // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è (–∏—Å–∫–ª—é—á–∞–µ–º IV –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –¥–ª—è —Ä–µ–∂–∏–º–æ–≤ —Å IV)
            let originalToCompare, modifiedToCompare;
            
            if (mode === 'ecb') {
                originalToCompare = originalEncrypted;
                modifiedToCompare = modifiedEncrypted;
            } else {
                // –î–ª—è —Ä–µ–∂–∏–º–æ–≤ —Å IV —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (–±–µ–∑ IV)
                originalToCompare = originalEncrypted.slice(16);
                modifiedToCompare = modifiedEncrypted.slice(16);
            }
            
            const changes = new Uint8Array(originalToCompare.length);
            let totalChanges = 0;
            
            for (let i = 0; i < originalToCompare.length; i++) {
                changes[i] = countBitDifferences(originalToCompare[i], modifiedToCompare[i]);
                totalChanges += changes[i];
            }
            
            const avalancheEffect = (totalChanges / (originalToCompare.length * 8)) * 100;
            
            return {
                changes: changes,
                totalChanges: totalChanges,
                totalBits: originalToCompare.length * 8,
                avalancheEffect: avalancheEffect
            };
        }
        
        // –ü–æ–¥—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ—Ç–ª–∏—á–∞—é—â–∏—Ö—Å—è –±–∏—Ç–æ–≤ –º–µ–∂–¥—É –¥–≤—É–º—è –±–∞–π—Ç–∞–º–∏
        function countBitDifferences(a, b) {
            let diff = a ^ b;
            let count = 0;
            
            while (diff) {
                count += diff & 1;
                diff >>= 1;
            }
            
            return count;
        }
        
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
        async function initializeCipher() {
            const key = document.getElementById('keyInput').value;
            const confirmation = document.getElementById('keyConfirmation').value;
            const iterations = parseInt(document.getElementById('pbkdf2Iterations').value);
            
            if (key !== confirmation) {
                alert('–ö–ª—é—á –∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç');
                return;
            }
            
            if (key.length < 12) {
                alert('–ö–ª—é—á –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—åËá≥Â∞ë 12 —Å–∏–º–≤–æ–ª–æ–≤');
                return;
            }
            
            try {
                document.getElementById('initStatus').textContent = '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...';
                
                cipherInstance = new ProfessionalHomophonicCipher();
                await cipherInstance.initializeWithKey(key, iterations);
                
                document.getElementById('initStatus').textContent = '–®–∏—Ñ—Ä —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω';
                document.getElementById('initStatus').style.color = '#3fb950';
                
            } catch (error) {
                document.getElementById('initStatus').textContent = '–û—à–∏–±–∫–∞: ' + error.message;
                document.getElementById('initStatus').style.color = '#f85149';
            }
        }
        
        async function encryptData() {
            if (!cipherInstance) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —à–∏—Ñ—Ä');
                return;
            }
            
            const inputText = document.getElementById('inputData').value;
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            const mode = document.getElementById('operationMode').value;
            
            try {
                const encryptedData = await cipherInstance.encrypt(inputText, mode);
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–µ—Å—Ç–∞ –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
                lastEncryptedData = encryptedData;
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ hex –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                const hexResult = Array.from(encryptedData).map(b => 
                    b.toString(16).padStart(2, '0')).join(' ');
                
                document.getElementById('outputData').textContent = hexResult;
                
                // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
                lastOperationResult = encryptedData;
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏
                let info = `–†–µ–∂–∏–º: ${mode.toUpperCase()}\n` +
                             `–†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö: ${inputText.length} –±–∞–π—Ç\n` +
                             `–†–∞–∑–º–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: ${encryptedData.length} –±–∞–π—Ç\n`;
                
                if (mode !== 'ecb') {
                    info += `IV: ${Array.from(encryptedData.slice(0, 16)).map(b => 
                                 b.toString(16).padStart(2, '0')).join(' ')}`;
                }
                
                document.getElementById('encryptionInfo').textContent = info;
                
            } catch (error) {
                document.getElementById('outputData').textContent = '–û—à–∏–±–∫–∞: ' + error.message;
            }
        }
        
        async function decryptData() {
            if (!cipherInstance) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —à–∏—Ñ—Ä');
                return;
            }
            
            const inputText = document.getElementById('inputData').value;
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            const mode = document.getElementById('operationMode').value;
            
            try {
                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ hex-—Å—Ç—Ä–æ–∫–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ –±–∞–π—Ç—ã
                const hexValues = inputText.trim().split(/\s+/);
                const byteArray = new Uint8Array(hexValues.map(h => parseInt(h, 16)));
                
                const decryptedText = await cipherInstance.decrypt(byteArray, mode);
                
                document.getElementById('outputData').textContent = decryptedText;
                
                // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
                const encoder = new TextEncoder();
                lastOperationResult = encoder.encode(decryptedText);
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏
                document.getElementById('encryptionInfo').textContent = 
                    `–†–µ–∂–∏–º: ${mode.toUpperCase()}\n` +
                    `–†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö: ${byteArray.length} –±–∞–π—Ç\n` +
                    `–†–∞–∑–º–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: ${decryptedText.length} —Å–∏–º–≤–æ–ª–æ–≤`;
                
            } catch (error) {
                document.getElementById('outputData').textContent = '–û—à–∏–±–∫–∞: ' + error.message;
            }
        }
        
        function clearAll() {
            document.getElementById('inputData').value = '';
            document.getElementById('outputData').textContent = '';
            document.getElementById('encryptionInfo').textContent = '';
            document.getElementById('initStatus').textContent = '–®–∏—Ñ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω';
            document.getElementById('initStatus').style.color = '';
            lastOperationResult = null;
            lastEncryptedData = null;
        }
        
        function switchTab(tabName) {
            // –°–∫—Ä—ã—Ç—å –≤—Å–µ –≤–∫–ª–∞–¥–∫–∏
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—É—é –≤–∫–ª–∞–¥–∫—É
            document.getElementById(tabName).classList.add('active');
            
            // –û–±–Ω–æ–≤–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—É—é –∫–Ω–æ–ø–∫—É –≤–∫–ª–∞–¥–∫–∏
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            event.currentTarget.classList.add('active');
        }
        
        // –§—É–Ω–∫—Ü–∏–∏ –∞–Ω–∞–ª–∏–∑–∞
        function runEntropyAnalysis() {
            if (!lastOperationResult || lastOperationResult.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏–ª–∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ');
                return;
            }
            
            const shannonEntropy = calculateShannonEntropy(lastOperationResult);
            const minEntropy = calculateMinEntropy(lastOperationResult);
            const chiSquareResult = calculateChiSquare(lastOperationResult);
            
            document.getElementById('shannonEntropy').textContent = shannonEntropy.toFixed(6);
            document.getElementById('minEntropy').textContent = minEntropy.toFixed(6);
            document.getElementById('chiSquare').textContent = chiSquareResult.chiSquare.toFixed(2);
            document.getElementById('pValue').textContent = chiSquareResult.pValue.toFixed(6);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∞–Ω–∞–ª–∏–∑–∞
            const analysisResults = document.getElementById('analysisResults');
            analysisResults.innerHTML = '';
            
            const tests = [
                { 
                    name: '–≠–Ω—Ç—Ä–æ–ø–∏—è –®–µ–Ω–Ω–æ–Ω–∞', 
                    value: shannonEntropy, 
                    pass: shannonEntropy > 7.9,
                    description: `–≠–Ω—Ç—Ä–æ–ø–∏—è: ${shannonEntropy.toFixed(6)} –±–∏—Ç/–±–∞–π—Ç (–∏–¥–µ–∞–ª: >7.9)`
                },
                { 
                    name: '–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è', 
                    value: minEntropy, 
                    pass: minEntropy > 7,
                    description: `–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è: ${minEntropy.toFixed(6)} –±–∏—Ç/–±–∞–π—Ç (–∏–¥–µ–∞–ª: >7)`
                },
                { 
                    name: 'œá¬≤ —Ç–µ—Å—Ç', 
                    value: chiSquareResult.chiSquare, 
                    pass: chiSquareResult.pValue > 0.05,
                    description: `œá¬≤: ${chiSquareResult.chiSquare.toFixed(2)}, p-value: ${chiSquareResult.pValue.toFixed(6)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: p > 0.05)`
                }
            ];
            
            for (const test of tests) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                const statusClass = test.pass ? 'test-pass' : 'test-fail';
                const statusText = test.pass ? '–ü–†–û–ô–î–ï–ù' : '–ù–ï –ü–†–û–ô–î–ï–ù';
                
                item.innerHTML = `
                    <div>${test.name}</div>
                    <div class="${statusClass}">${statusText}</div>
                `;
                
                analysisResults.appendChild(item);
                
                const desc = document.createElement('div');
                desc.className = 'test-item';
                desc.innerHTML = test.description;
                analysisResults.appendChild(desc);
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–∫–ª—é—á–µ–Ω–∏—è
            document.getElementById('frequencyResistance').textContent = 
                shannonEntropy > 7.9 ? '–í—ã—Å–æ–∫–∞—è' : '–°—Ä–µ–¥–Ω—è—è';
            document.getElementById('entropyEfficiency').textContent = 
                shannonEntropy > 7.9 ? '–í—ã—Å–æ–∫–∞—è' : '–°—Ä–µ–¥–Ω—è—è';
        }
        
        function runFrequencyTest() {
            if (!lastOperationResult || lastOperationResult.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏–ª–∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ');
                return;
            }
            
            const frequencies = frequencyAnalysis(lastOperationResult);
            if (!frequencies) return;
            
            const analysisResults = document.getElementById('analysisResults');
            analysisResults.innerHTML = '';
            
            // –°–æ–∑–¥–∞–µ–º –≥–∏—Å—Ç–æ–≥—Ä–∞–º–º—É
            const histogram = document.getElementById('byteHistogram');
            histogram.innerHTML = '';
            
            const distribution = document.getElementById('byteDistribution');
            distribution.innerHTML = '';
            
            const maxFreq = Math.max(...frequencies);
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º –≥–∏—Å—Ç–æ–≥—Ä–∞–º–º—É
            for (let i = 0; i < 256; i++) {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${(frequencies[i] / maxFreq) * 100}%`;
                bar.title = `Byte ${i}: ${frequencies[i]} occurrences`;
                histogram.appendChild(bar);
            }
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –±–∞–π—Ç–æ–≤
            for (let i = 0; i < 256; i++) {
                const cell = document.createElement('div');
                cell.className = 'byte-cell';
                
                const fill = document.createElement('div');
                fill.className = 'byte-fill';
                fill.style.height = `${(frequencies[i] / maxFreq) * 100}%`;
                
                const value = document.createElement('div');
                value.className = 'byte-value';
                value.textContent = i.toString(16).toUpperCase().padStart(2, '0');
                
                cell.appendChild(fill);
                cell.appendChild(value);
                distribution.appendChild(cell);
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ—Å—Ç–µ
            const expected = lastOperationResult.length / 256;
            const uniformity = frequencies.reduce((sum, freq) => sum + Math.pow(freq - expected, 2), 0) / expected;
            
            const item = document.createElement('div');
            item.className = 'test-item';
            item.innerHTML = `
                <div>–ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑</div>
                <div class="test-info">–í–´–ü–û–õ–ù–ï–ù–û</div>
            `;
            analysisResults.appendChild(item);
            
            const desc = document.createElement('div');
            desc.className = 'test-item';
            desc.innerHTML = `–†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç—å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è: ${uniformity.toFixed(2)} (–∏–¥–µ–∞–ª: –±–ª–∏–∑–∫–æ –∫ 0)`;
            analysisResults.appendChild(desc);
        }
        
        async function runAvalancheTest() {
            if (!cipherInstance || !lastOperationResult) {
                alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ');
                return;
            }
            
            try {
                const mode = document.getElementById('operationMode').value;
                const analysisResults = document.getElementById('analysisResults');
                analysisResults.innerHTML = '<div class="test-item">–í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–µ—Å—Ç –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞...</div>';
                
                // –î–ª—è —Ç–µ—Å—Ç–∞ –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –¥–∞–Ω–Ω—ã–µ (–±–µ–∑ IV)
                const dataToTest = mode === 'ecb' ? lastOperationResult : lastOperationResult.slice(16);
                
                const avalancheResult = await runAvalancheTestInternal(cipherInstance, dataToTest, mode);
                
                analysisResults.innerHTML = '';
                
                const item = document.createElement('div');
                item.className = 'test-item';
                item.innerHTML = `
                    <div>–¢–µ—Å—Ç –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞</div>
                    <div class="test-info">–í–´–ü–û–õ–ù–ï–ù–û</div>
                `;
                analysisResults.appendChild(item);
                
                const desc = document.createElement('div');
                desc.className = 'test-item';
                desc.innerHTML = `–õ–∞–≤–∏–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç: ${avalancheResult.avalancheEffect.toFixed(2)}% (–∏–¥–µ–∞–ª: ~50%)`;
                analysisResults.appendChild(desc);
                
                const details = document.createElement('div');
                details.className = 'test-details';
                details.innerHTML = `
                    –ò–∑–º–µ–Ω–µ–Ω–æ –±–∏—Ç–æ–≤: ${avalancheResult.totalChanges} –∏–∑ ${avalancheResult.totalBits}<br>
                    –ü—Ä–æ—Ü–µ–Ω—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è: ${avalancheResult.avalancheEffect.toFixed(2)}%<br>
                    <small>–¢–µ—Å—Ç –∏–∑–º–µ–Ω—è–µ—Ç –æ–¥–∏–Ω –±–∏—Ç –≤–æ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ –∏–∑–º–µ—Ä—è–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –∏–∑–º–µ–Ω–µ–Ω–Ω—ã—Ö –±–∏—Ç–æ–≤ –≤ –≤—ã—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö</small>
                `;
                analysisResults.appendChild(details);
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–∫–ª—é—á–µ–Ω–∏—è
                document.getElementById('avalancheEffect').textContent = 
                    avalancheResult.avalancheEffect > 45 && avalancheResult.avalancheEffect < 55 ? 
                    '–•–æ—Ä–æ—à–∏–π' : '–°–ª–∞–±—ã–π';
                    
            } catch (error) {
                document.getElementById('analysisResults').innerHTML = 
                    `<div class="test-item">–û—à–∏–±–∫–∞: ${error.message}</div>`;
            }
        }
        
        function runRandomnessTests() {
            if (!lastOperationResult || lastOperationResult.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏–ª–∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ');
                return;
            }
            
            const piEstimate = calculatePiEstimate(lastOperationResult);
            const runs = calculateRuns(lastOperationResult);
            const autocorrelation = calculateAutocorrelation(lastOperationResult, 1);
            
            document.getElementById('piEstimate').textContent = piEstimate.toFixed(6);
            document.getElementById('runsCount').textContent = runs;
            
            const analysisResults = document.getElementById('analysisResults');
            analysisResults.innerHTML = '';
            
            const tests = [
                { 
                    name: '–û—Ü–µ–Ω–∫–∞ —á–∏—Å–ª–∞ œÄ', 
                    value: piEstimate, 
                    pass: Math.abs(piEstimate - Math.PI) < 0.05,
                    description: `œÄ ‚âà ${piEstimate.toFixed(6)} (–æ—à–∏–±–∫–∞: ${Math.abs(piEstimate - Math.PI).toFixed(6)})`
                },
                { 
                    name: '–¢–µ—Å—Ç —Å–µ—Ä–∏–π (runs)', 
                    value: runs, 
                    pass: runs > lastOperationResult.length * 0.4 && runs < lastOperationResult.length * 0.6,
                    description: `Runs: ${runs} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ~${Math.round(lastOperationResult.length / 2)})`
                },
                { 
                    name: '–ê–≤—Ç–æ–∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è (lag=1)', 
                    value: autocorrelation, 
                    pass: Math.abs(autocorrelation) < 0.1,
                    description: `–ê–≤—Ç–æ–∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è: ${autocorrelation.toFixed(6)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: |r| < 0.1)`
                }
            ];
            
            for (const test of tests) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                const statusClass = test.pass ? 'test-pass' : 'test-fail';
                const statusText = test.pass ? '–ü–†–û–ô–î–ï–ù' : '–ù–ï –ü–†–û–ô–î–ï–ù';
                
                item.innerHTML = `
                    <div>${test.name}</div>
                    <div class="${statusClass}">${statusText}</div>
                `;
                
                analysisResults.appendChild(item);
                
                const desc = document.createElement('div');
                desc.className = 'test-item';
                desc.innerHTML = test.description;
                analysisResults.appendChild(desc);
            }
        }
        
        function runAllTests() {
            runEntropyAnalysis();
            runFrequencyTest();
            runAvalancheTest();
            runRandomnessTests();
        }
        
        function analyzeSBox() {
            if (!cipherInstance) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —à–∏—Ñ—Ä');
                return;
            }
            
            const properties = cipherInstance.getSBoxProperties();
            if (!properties) {
                alert('S-Box –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω');
                return;
            }
            
            const sboxProperties = document.getElementById('sboxProperties');
            sboxProperties.innerHTML = '';
            
            const props = [
                { name: '–†–∞–∑–º–µ—Ä S-Box', value: properties.size },
                { name: '–í—Å–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤', value: properties.totalElements },
                { name: '–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤', value: properties.uniqueHomophonesCount },
                { name: '–û—Ö–≤–∞—Ç –∑–Ω–∞—á–µ–Ω–∏–π', value: `${properties.uniqueHomophonesCount}/65536` },
                { name: '–†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç—å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è', value: properties.uniformityScore.toFixed(2) }
            ];
            
            for (const prop of props) {
                const item = document.createElement('div');
                item.className = 'test-item';
                item.innerHTML = `
                    <div>${prop.name}</div>
                    <div>${prop.value}</div>
                `;
                sboxProperties.appendChild(item);
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–∫–ª—é—á–µ–Ω–∏—è
            document.getElementById('frequencyResistance').textContent = 
                properties.uniformityScore < 500 ? '–í—ã—Å–æ–∫–∞—è' : '–°—Ä–µ–¥–Ω—è—è';
            document.getElementById('differentialResistance').textContent = 
                properties.uniqueHomophonesCount === 65536 ? '–í—ã—Å–æ–∫–∞—è' : '–°—Ä–µ–¥–Ω—è—è';
            document.getElementById('entropyEfficiency').textContent = 
                properties.uniqueHomophonesCount === 65536 ? '–ò–¥–µ–∞–ª—å–Ω–∞—è' : '–•–æ—Ä–æ—à–∞—è';
        }
        
        function visualizeSBox() {
            if (!cipherInstance || !cipherInstance.sBox) {
                alert('S-Box –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω');
                return;
            }
            
            const sboxTable = document.getElementById('sboxTable');
            sboxTable.innerHTML = '';
            
            // –ó–∞–≥–æ–ª–æ–≤–æ–∫
            const emptyHeader = document.createElement('div');
            emptyHeader.className = 'sbox-header';
            sboxTable.appendChild(emptyHeader);
            
            for (let j = 0; j < 16; j++) {
                const header = document.createElement('div');
                header.className = 'sbox-header';
                header.textContent = j.toString(16).toUpperCase();
                sboxTable.appendChild(header);
            }
            
            // –î–∞–Ω–Ω—ã–µ S-Box (–ø–µ—Ä–≤—ã–µ 16x16 –∑–Ω–∞—á–µ–Ω–∏–π)
            for (let i = 0; i < 16; i++) {
                const rowHeader = document.createElement('div');
                rowHeader.className = 'sbox-header';
                rowHeader.textContent = i.toString(16).toUpperCase();
                sboxTable.appendChild(rowHeader);
                
                for (let j = 0; j < 16; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'sbox-cell';
                    
                    const byteValue = i * 16 + j;
                    const homophone = cipherInstance.sBox[byteValue][0]; // –ü–µ—Ä–≤—ã–π –æ–º–æ—Ñ–æ–Ω –¥–ª—è —è—á–µ–π–∫–∏
                    
                    cell.textContent = homophone.toString(16).padStart(4, '0');
                    cell.title = `S-Box[${byteValue}][0] = ${homophone}`;
                    
                    sboxTable.appendChild(cell);
                }
            }
        }
    </script>
</body>
</html>
